[{"title":"图论常用模板","url":"/2025/12/10/%E5%9B%BE%E8%AE%BA%E5%B8%B8%E7%94%A8%E6%A8%A1%E6%9D%BF/","content":" 图论核心算法模板\n 1. 图的存储模板\n 邻接表（稀疏图首选）\n#include &lt;vector&gt;using namespace std;const int N = 1e5 + 10; // 节点数上限vector&lt;pair&lt;int, int&gt;&gt; adj[N]; // adj[u]存储(v, w)：u→v，边权w// 建图：添加有向边u→v，边权w（无向边需加两次u→v和v→u）void add_edge(int u, int v, int w = 1) &#123; // 无权重时w默认1    adj[u].emplace_back(v, w);&#125;// 遍历u的所有出边void traverse(int u) &#123;    for (auto &amp;e : adj[u]) &#123;        int v = e.first, w = e.second;        // 处理边u→v    &#125;&#125;\n 链式前向星（高效存边，竞赛高频）\n 第一种 使用结构体存储\n#include &lt;cstring&gt;using namespace std;const int N = 1e5 + 10, M = 2e5 + 10; // N节点数，M边数上限int head[N], idx; // head[u]表示u的第一条边索引，idx边的计数器struct Edge &#123; int v, w, next; &#125; edge[M]; // next指向下一条边// 初始化void init() &#123;    memset(head, -1, sizeof head);    idx = 0;&#125;// 建图：添加有向边u→v，边权w（无向边需加两次）void add_edge(int u, int v, int w = 1) &#123;    edge[idx] = &#123;v, w, head[u]&#125;;    head[u] = idx++;&#125;// 遍历u的所有出边void traverse(int u) &#123;    for (int i = head[u]; i != -1; i = edge[i].next) &#123;        int v = edge[i].v, w = edge[i].w;        // 处理边u→v    &#125;&#125;\n 第二种 使用数组存储\n链式前向星\n\n 2. 图的遍历模板\n DFS（递归版，适用于无栈溢出场景）\nAcWing 846. 树的重心\n模板：\n#include &lt;vector&gt;#include &lt;cstring&gt;using namespace std;const int N = 1e5 + 10;vector&lt;int&gt; adj[N];bool st[N]; // 标记是否访问过void dfs(int u) &#123;    st[u] = true; // 标记访问    for (int v : adj[u]) &#123;        if (!st[v]) &#123;            dfs(v);            // 回溯时操作（如统计子树大小）        &#125;    &#125;&#125;\n例题代码:\n#include &lt;bits/stdc++.h&gt;using namespace std;using ll = long long;const int N = 1e5 + 10, M = 2 * N;int n, ans=N;int h[N], e[M], ne[M], idx, st[N];void add(int a, int b)&#123;    e[idx] = b, ne[idx] = h[a], h[a] = idx++;&#125;int dfs(int u)&#123;    st[u] = 1; // 防止重复遍历     int sum = 1, res = 0;    for (int i = h[u]; i != -1; i = ne[i])    &#123;        int j = e[i];        if(!st[j])        &#123;            int s = dfs(j);            res = max(res, s); // 先在当前u的子树中求一个节点最大值             sum += s; // 表示u节点子树的节点的总和         &#125;    &#125;    res = max(res, n - sum); // 再在以u的父节点为子树的求一个节点最大值     ans = min(ans, res); // 求最大值的最小值     return sum;&#125;int main()&#123;    cin &gt;&gt; n;    memset(h, -1, sizeof h);    for (int i = 1, u, v; i &lt; n; i ++)      &#123;        cin &gt;&gt; u &gt;&gt; v;        add(u, v);        add(v, u);    &#125;    dfs(1);    cout &lt;&lt; ans &lt;&lt; endl;    return 0;&#125;\n BFS（队列版，无权图最短路径）\nAcWing 847. 图中点的层次\n模板：\n#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;cstring&gt;using namespace std;const int N = 1e5 + 10;vector&lt;int&gt; adj[N];bool st[N]; // 计算距离的时候，可省略int dist[N]; // 存储到起点的距离void bfs(int start) &#123;    memset(st, false, sizeof st);    memset(dist, -1, sizeof dist);    queue&lt;int&gt; q;    q.push(start);    st[start] = true;    dist[start] = 0;      while (!q.empty()) &#123;        int u = q.front();        q.pop();        for (int v : adj[u]) &#123;            if (!st[v]) &#123;                // if这里可以直接对下一个点的距离是否为 -1，进行判断                st[v] = true;                dist[v] = dist[u] + 1;                q.push(v);            &#125;        &#125;    &#125;&#125;\n例题代码:\n// 使用邻接表存储图#include &lt;bits/stdc++.h&gt;using namespace std;using ll = long long;typedef pair&lt;int, int&gt; pii;const int N = 1e5 + 10;vector&lt;pii&gt; adj[N];int n, m, dist[N];void add(int u, int v, int w)&#123;    adj[u].emplace_back(v, w);&#125;int bfs() &#123;    memset(dist, -1, sizeof dist);      queue&lt;int&gt; q;      q.push(1);    dist[1] = 0;    while(q.size())    &#123;        int t = q.front(); q.pop();        for (auto &amp;e : adj[t])        &#123;            int nxt = e.first, distance = e.second;            if(dist[nxt] == -1)            &#123;                dist[nxt] = dist[t] + distance;                q.push(nxt);            &#125;        &#125;    &#125;    return dist[n];&#125;int main()&#123;    cin &gt;&gt; n &gt;&gt; m;    for (int i = 1, u, v; i &lt;= m; i ++)    &#123;        cin &gt;&gt; u &gt;&gt; v;        add(u, v, 1);    &#125;     cout &lt;&lt; bfs() &lt;&lt; endl;    return 0;&#125;\n// 使用数组模拟邻接表#include &lt;bits/stdc++.h&gt;using namespace std;using ll = long long;const int N = 1e5 + 10;int n, m;int h[N], e[N], ne[N], idx;int dist[N], q[N];void add(int a, int b) &#123;    e[idx] = b;    ne[idx] = h[a];    h[a] = idx;    idx ++;&#125;// 手写队列实现int bfs() &#123;    memset(dist, -1, sizeof dist);    int tt = 0, hh = 0;    q[0] = 1;    dist[1] = 0;    while(hh &lt;= tt) &#123;        auto t = q[hh ++];        for (int i = h[t]; i != -1; i = ne[i]) &#123;            int j = e[i];            if(dist[j] == -1) &#123;                dist[j] = dist[t] + 1;                q[++ tt] = j;            &#125;        &#125;    &#125;    return dist[n];&#125;int bfs_stl() &#123;    memset(dist, -1, sizeof dist);    queue&lt;int&gt; q;    q.push(1);    dist[1] = 0;    while(q.size()) &#123;        auto t = q.front();        q.pop();        for (int i = h[t]; i != -1; i = ne[i]) &#123;            int j = e[i];            if (dist[j] == -1) &#123;                dist[j] = dist[t] + 1;                q.push(j);            &#125;        &#125;    &#125;    return dist[n];&#125;int main()&#123;    cin &gt;&gt; n &gt;&gt; m;    memset(h, -1, sizeof h); // 一定要注意初始化表头     for (int i = 0, u, v; i &lt; m; i ++) &#123;        int a, b;        cin &gt;&gt; u &gt;&gt; v;        add(u, v);    &#125;    cout &lt;&lt; bfs_stl() &lt;&lt; endl;      return 0;&#125;\n\n 3. 并查集（路径压缩+按秩合并）\nconst int N = 1e5 + 10;int parent[N]; // 父节点int rank_[N]; // 秩（树的高度）// 初始化void init() &#123;    for (int i = 0; i &lt; N; i++) &#123;        parent[i] = i;        rank_[i] = 1;    &#125;&#125;// 查找根节点（路径压缩）int find(int x) &#123;    if (parent[x] != x) parent[x] = find(parent[x]);    return parent[x];&#125;// 合并（按秩合并）void unite(int x, int y) &#123;    x = find(x), y = find(y);    if (x == y) return;    if (rank_[x] &lt; rank_[y]) swap(x, y);    parent[y] = x;    if (rank_[x] == rank_[y]) rank_[x]++;&#125;\n\n 4. 最短路径算法模板\n Dijkstra（正权图单源最短路径）\n 算法描述：\n\n初始化 dist[1] = 0, 其余节点的 dist 值为无穷大。\n找出第一个未被标记的，dist[x] 最小的节点 x, 然后标记节点 x。\n扫描节点 x 的所有出边 (x, y, z)， 若 dist[y] &gt; dist[x] + z， 则使用 dist[x] + z 更新 dist[y]。\n重复上述 2 ～ 3 两个步骤，直到所有的节点都被标记。\n\nAcWing 849. Dijkstra求最短路 I\n例题代码:\n// 稠密图这里使用邻接数组#include &lt;bits/stdc++.h&gt;using namespace std;using ll = long long;const int N = 550;int n, m;int g[N][N], dist[N], st[N];int dijkstra()&#123;    // 时间复杂度为 O(n^2)    memset(dist, 0x3f, sizeof dist);    dist[1] = 0;      for (int i = 1; i &lt; n; i ++) // 重复 n - 1 次    &#123;        int t = -1;        for (int j = 1; j &lt;= n; j ++) // 找到未标记节点中 dist 最小的 (瓶颈主要在这里，可使用二叉堆优化)        &#123;            if(!st[j] &amp;&amp; (t == -1 || dist[t] &gt; dist[j])) t = j;        &#125;        st[t] = 1;        // 用全局最小值点 x 更新其他节点        for (int j = 1; j &lt;= n; j ++)            dist[j] = min(dist[j], dist[t] + g[t][j]);    &#125;      if(dist[n] == 0x3f3f3f3f) return -1;    else return dist[n];&#125;int main()&#123;    cin &gt;&gt; n &gt;&gt; m;    memset(g, 0x3f, sizeof g);    for (int i = 1, u, v, w; i &lt;= m; i ++)    &#123;        cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;        g[u][v] = min(g[u][v], w);    &#125;    cout &lt;&lt; dijkstra();    return 0;&#125;\n// 使用邻接表实现#include &lt;bits/stdc++.h&gt;using namespace std;using ll = long long;const int N = 1e6 + 10;typedef pair&lt;int, int&gt; pii;int n, m; int e[N], ne[N], h[N], val[N], dist[N], st[N], idx;void add(int a, int b, int w)&#123;    e[++ idx] = b, val[idx] = w, ne[idx] = h[a], h[a] = idx;&#125;int dijkstra()&#123;    memset(dist, 0x3f, sizeof dist);    dist[1] = 0;      priority_queue&lt;pii, vector&lt;pii&gt;, greater&lt;pii&gt;&gt; q;    q.push(&#123;0, 1&#125;);        while(q.size())    &#123;        pii t = q.top(); q.pop();            int distance = t.first, ver = t.second;            if(st[ver]) continue;        st[ver] = 1;            for (int i = h[ver]; i != -1; i = ne[i])        &#123;            int j = e[i];            if(dist[j] &gt; dist[ver] + val[i])            &#123;                dist[j] = dist[ver] + val[i];                q.push(&#123;dist[j], j&#125;);            &#125;        &#125;    &#125;      if(dist[n] == 0x3f3f3f3f) return -1;    else return dist[n];&#125;int main()&#123;    memset(h, -1, sizeof h);    cin &gt;&gt; n &gt;&gt; m;    for (int i = 1, u, v, w; i &lt;= m; i ++)    &#123;        cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;        add(u, v, w);    &#125;    cout &lt;&lt; dijkstra();    return 0;   &#125;\n模板:\n#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;cstring&gt;using namespace std;typedef pair&lt;int, int&gt; PII; // 第一维距离，第二维节点const int N = 1e5 + 10, INF = 0x3f3f3f3f;vector&lt;PII&gt; adj[N];int dist[N];bool st[N]; // 标记是否确定最短距离void dijkstra(int start) &#123;    memset(dist, 0x3f, sizeof dist);    memset(st, false, sizeof st);    priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt;&gt; heap; // 小根堆    dist[start] = 0;    heap.push(&#123;0, start&#125;);      while (!heap.empty()) &#123;        auto [d, u] = heap.top();        heap.pop();        if (st[u]) continue;        st[u] = true;        for (auto [v, w] : adj[u]) &#123;            if (dist[v] &gt; dist[u] + w) &#123;                dist[v] = dist[u] + w;                heap.push(&#123;dist[v], v&#125;);            &#125;        &#125;    &#125;&#125;\n Floyd-Warshall（多源最短路径）\nconst int N = 510, INF = 0x3f3f3f3f;int dist[N][N]; // dist[i][j]表示i到j的最短距离int n; // 节点数// 初始化void init() &#123;    for (int i = 1; i &lt;= n; i++) &#123;        for (int j = 1; j &lt;= n; j++) &#123;            dist[i][j] = i == j ? 0 : INF;        &#125;    &#125;&#125;// 核心算法void floyd() &#123;    for (int k = 1; k &lt;= n; k++) &#123; // 中间节点        for (int i = 1; i &lt;= n; i++) &#123;            for (int j = 1; j &lt;= n; j++) &#123;                if (dist[i][k] != INF &amp;&amp; dist[k][j] != INF) &#123;                    dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);                &#125;            &#125;        &#125;    &#125;&#125;\n SPFA（队列优化，负权图单源最短路径，可检测负环）\n 算法描述 (求最短路)\n\n建立一个的队列，最初队列中只含有起点 1。\n取出对头节点 x，扫描它的所有出边 (x, y, z), 若 dist[y] &gt; dist[x] + z, 则使用 dist[x] + z 更新 dist[y]。同时，若 y 不在队列中，则把 y 入队。\n重复以上操作，直至队列为空。\n\nAcWing 851. spfa求最短路\n#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 1e5 + 10;int n, m;int h[N], ne[N], e[N], w[N], idx;int dist[N], st[N];inline void add(int a, int b, int v)&#123;    e[++ idx] = b, w[idx] = v, ne[idx] = h[a], h[a] = idx;&#125;int spfa()&#123;    memset(dist, 0x3f, sizeof dist);    queue&lt;int&gt; q;      q.push(1);      dist[1] = 0;    st[1] = 1; // 标记节点是否在队列之中      while(q.size())    &#123;        int t = q.front(); q.pop();            st[t] = 0;            for (int i = h[t]; ~i; i = ne[i])        &#123;            int j = e[i];            if(dist[j] &gt; dist[t] + w[i])            &#123;                dist[j] = dist[t] + w[i];                if(!st[j])                &#123;                    q.push(j);                    st[j] = 1;                &#125;            &#125;        &#125;    &#125;      return dist[n];&#125;int main()&#123;    cin &gt;&gt; n &gt;&gt; m;    memset(h, -1, sizeof h);    for (int i = 1, u, v, val; i &lt;= m; i ++)    &#123;        cin &gt;&gt; u &gt;&gt; v &gt;&gt; val;        add(u, v, val);    &#125;    int t = spfa();    if(t == 0x3f3f3f3f) puts(&quot;impossible&quot;);    else cout &lt;&lt; t &lt;&lt; &quot;\\n&quot;;    return 0;&#125;\n 判断负环：\n\n若最短路径不存在负权回路，任意两点间最短简单路径最多含 n-1  条边n 为总点数。因此通过 n-1  次松弛操作可得到最短距离；若仍能松弛，则存在可无限减少路径长度的负权环。\n\n 常用方法\n统计每个结点被入队/被松弛的次数  cnt[v] 。当 cnt[v]≥ncnt[v] \\geq ncnt[v]≥n 或 &gt;n−1&gt;n-1&gt;n−1 时，说明从源点到该结点存在一条含至少 n  条边且仍能松弛的路径，即存在从源可达的负权回路。\n 实现要点\n\n松弛时的计数逻辑：\n\n当松弛到  v 且需要将 v 放入队列时，执行 cnt[v]++；若 cnt[v] &gt;= n，则报告负环。\n也可在每次真正更新  dist[v] 时执行 cnt[v]++，两种方式等价用于检测。\n\n\n\n 负环回溯方法\n\n记录每次松弛时的前驱 pre[v] = u。\n当检测到结点  x  满足 cnt[x] &gt; n：\n\n令 y = x ，重复  n  次 y = pre[y]（确保跳到环上的点）；\n从 y 沿 pre 链回溯并收集节点，直到回到  y ，即可得到一个负权回路。\n\n\n\n 可达性与全图负环检测\n\n上述方法仅能检测“从源可达”的负环。若要检测图中任意负环，可添加一个超级源点，向所有结点连权值为 0 的边，再用算法跑一次（或对每个连通分量分别处理）。\n\n 简短结论\nSPFA 通过统计每个节点被松弛/入队次数 cnt[v] ，一旦  cnt[v] &gt;= n  即可判定存在从源可达的负权回路；回溯时利用前驱链并先跳 n 步，确保进入环内。\nAcWing 852. spfa判断负环\n#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 1e5 + 10;int n, m;int e[N], ne[N], w[N], h[N], idx;int dist[N], cnt[N], st[N];// 这里的 dist 数组可以省略掉， 如果存在负权回路的话， dist 数组值会无限被更新。// 但是，cnt 数组防止了，无限继续先去，cnt 数组用来存储入队次数。// 存在一个点数为 n 的图，那么到当前节点的入队次数最大为 n - 1，// 当入队次数 &gt;= n 时候，必然存在负数回路。inline void add(int a, int b, int v)&#123;       e[++ idx] = b, w[idx] = v, ne[idx] = h[a], h[a] = idx;&#125;bool spfa()&#123;    memset(dist, 0x3f, sizeof dist);    queue&lt;int&gt; q;     // 这里因为要判断图中是否存在负环    // 那么，需要将所有节点都先入队，然后计算 cnt 数组    for (int i = 1; i &lt;= n; i ++)    &#123;        st[i] = 1;        q.push(i);    &#125;      while(q.size())    &#123;        int t = q.front();        q.pop();            st[t] = 0;            for (int i = h[t]; ~i; i = ne[i])        &#123;            int j = e[i];            if(dist[j] &gt; dist[t] + w[i])            &#123;                dist[j] = dist[t] + w[i]; // 更新距离后记得更新 cnt 数组                cnt[j] = cnt[t] + 1;                            if(cnt[j] &gt;= n) return 1;                if(!st[j])                &#123;                    q.push(j);                    st[j] = 1;                &#125;            &#125;        &#125;    &#125;    return 0;&#125;int main() &#123;    cin &gt;&gt; n &gt;&gt; m;    memset(h, -1, sizeof h);    for (int i = 1, u, v, val; i &lt;= m; i ++)    &#123;        cin &gt;&gt; u &gt;&gt; v &gt;&gt; val;        add(u, v, val);    &#125;    if(spfa()) puts(&quot;Yes&quot;);    else puts(&quot;No&quot;);    return 0;&#125;\n模板：\n#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;cstring&gt;using namespace std;const int N = 1e5 + 10, INF = 0x3f3f3f3f;vector&lt;pair&lt;int, int&gt;&gt; adj[N];int dist[N];int cnt[N]; // 记录入队次数，判断负环bool inqueue[N]; // 标记是否在队列中int n, m; // 节点数、边数// 返回true表示存在负环bool spfa(int start) &#123;    memset(dist, 0x3f, sizeof dist);    memset(cnt, 0, sizeof cnt);    memset(inqueue, false, sizeof inqueue);    queue&lt;int&gt; q;    dist[start] = 0;    q.push(start);    inqueue[start] = true;      while (!q.empty()) &#123;        int u = q.front();        q.pop();        inqueue[u] = false;        for (auto [v, w] : adj[u]) &#123;            if (dist[v] &gt; dist[u] + w) &#123;                dist[v] = dist[u] + w;                cnt[v] = cnt[u] + 1;                if (cnt[v] &gt;= n) return true; // 入队n次，存在负环                if (!inqueue[v]) &#123;                     q.push(v);                    inqueue[v] = true;                &#125;            &#125;        &#125;    &#125;    return false;&#125;\n\n 5. 最小生成树模板\n Kruskal（并查集+排序，稀疏图首选）\n#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;const int N = 1e5 + 10, M = 2e5 + 10;struct Edge &#123;    int u, v, w;    bool operator&lt;(const Edge &amp;e) const &#123;        return w &lt; e.w; // 按边权升序排序    &#125;&#125; edges[M];int parent[N];int n, m; // 节点数、边数// 并查集find和init函数同前int find(int x) &#123; /* 路径压缩实现 */ &#125;void init() &#123; /* 初始化实现 */ &#125;int kruskal() &#123;    sort(edges, edges + m);    init();    int res = 0, cnt = 0; // res总权值，cnt选边数    for (int i = 0; i &lt; m; i++) &#123;        int u = edges[i].u, v = edges[i].v, w = edges[i].w;        u = find(u), v = find(v);        if (u != v) &#123;            unite(u, v);            res += w;            cnt++;            if (cnt == n - 1) break; // 选够n-1条边，退出        &#125;    &#125;    return cnt == n - 1 ? res : -1; // 不连通返回-1&#125;\n Prim（堆优化，稠密图首选）\n#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;cstring&gt;using namespace std;typedef pair&lt;int, int&gt; PII; // 第一维边权，第二维节点const int N = 1e5 + 10, INF = 0x3f3f3f3f;vector&lt;PII&gt; adj[N];bool st[N]; // 标记是否已加入生成树int n, m;int prim() &#123;    memset(st, false, sizeof st);    priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt;&gt; heap;    heap.push(&#123;0, 1&#125;); // 从节点1开始（可修改起点）    int res = 0, cnt = 0;      while (!heap.empty()) &#123;        auto [w, u] = heap.top();        heap.pop();        if (st[u]) continue;        st[u] = true;        res += w;        cnt++;        for (auto [v, ww] : adj[u]) &#123;            if (!st[v]) heap.push(&#123;ww, v&#125;);        &#125;    &#125;    return cnt == n ? res : -1; // 不连通返回-1&#125;\n\n 6. 强连通分量（Tarjan算法+缩点）\n#include &lt;vector&gt;#include &lt;stack&gt;#include &lt;cstring&gt;using namespace std;const int N = 1e5 + 10;vector&lt;int&gt; adj[N];int dfn[N], low[N], timestamp; // dfn时间戳，low能到达的最早时间戳bool in_stack[N]; // 标记是否在栈中stack&lt;int&gt; stk;int scc_cnt; // 强连通分量数量int id[N]; // 每个节点所属的强连通分量编号int n, m;void tarjan(int u) &#123;    dfn[u] = low[u] = ++timestamp;    stk.push(u);    in_stack[u] = true;    for (int v : adj[u]) &#123;        if (!dfn[v]) &#123;            tarjan(v);            low[u] = min(low[u], low[v]);        &#125; else if (in_stack[v]) &#123;            low[u] = min(low[u], dfn[v]);        &#125;    &#125;    // 找到强连通分量的根    if (dfn[u] == low[u]) &#123;        scc_cnt++;        int v;        do &#123;            v = stk.top();            stk.pop();            in_stack[v] = false;            id[v] = scc_cnt;        &#125; while (v != u);    &#125;&#125;// 缩点：构建新的DAGvector&lt;int&gt; new_adj[N];int scc_size[N]; // 每个强连通分量的大小void shrink() &#123;    memset(dfn, 0, sizeof dfn);    memset(low, 0, sizeof low);    memset(in_stack, false, sizeof in_stack);    timestamp = scc_cnt = 0;    for (int i = 1; i &lt;= n; i++) &#123;        if (!dfn[i]) tarjan(i);    &#125;    // 统计每个SCC大小    for (int i = 1; i &lt;= n; i++) scc_size[id[i]]++;    // 建DAG    for (int u = 1; u &lt;= n; u++) &#123;        for (int v : adj[u]) &#123;            if (id[u] != id[v]) &#123;                new_adj[id[u]].push_back(id[v]);            &#125;        &#125;    &#125;&#125;\n\n 7. 二分图匹配（匈牙利算法）\n#include &lt;vector&gt;#include &lt;cstring&gt;using namespace std;const int N = 1e3 + 10, M = 1e5 + 10;vector&lt;int&gt; adj[N]; // 左部节点→右部节点int match[M]; // 右部节点匹配的左部节点bool st[M]; // 标记右部节点是否被访问int n1, n2; // 左部节点数、右部节点数// 尝试给左部节点u找匹配bool find(int u) &#123;    for (int v : adj[u]) &#123;        if (!st[v]) &#123;            st[v] = true;            if (match[v] == 0 || find(match[v])) &#123;                match[v] = u;                return true;            &#125;        &#125;    &#125;    return false;&#125;// 求最大匹配数int hungarian() &#123;    memset(match, 0, sizeof match);    int res = 0;    for (int u = 1; u &lt;= n1; u++) &#123;        memset(st, false, sizeof st);        if (find(u)) res++;    &#125;    return res;&#125;\n\n 8. 拓扑排序（Kahn算法）\n#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;cstring&gt;using namespace std;const int N = 1e5 + 10;vector&lt;int&gt; adj[N];int in_degree[N]; // 入度int topo[N]; // 存储拓扑序列int n, m;// 返回拓扑序列长度，0表示有环int kahn() &#123;    queue&lt;int&gt; q;    int cnt = 0; // 拓扑序列长度    // 入度为0的节点入队    for (int i = 1; i &lt;= n; i++) &#123;        if (in_degree[i] == 0) q.push(i);    &#125;    while (!q.empty()) &#123;        int u = q.front();        q.pop();        topo[cnt++] = u;        for (int v : adj[u]) &#123;            in_degree[v]--;            if (in_degree[v] == 0) q.push(v);        &#125;    &#125;    return cnt == n ? cnt : 0;&#125;\n\n 9. 网络流（Dinic算法，最大流）\n#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;cstring&gt;using namespace std;const int N = 1e4 + 10, M = 2e5 + 10, INF = 1e9;struct Edge &#123;    int v, c, rev; // 终点、剩余容量、反向边索引&#125;;vector&lt;Edge&gt; adj[N];int level[N]; // 分层图深度int ptr[N]; // 当前弧优化int n, m, s, t; // 节点数、边数、源点、汇点// 添加边u→v，容量cvoid add_edge(int u, int v, int c) &#123;    adj[u].push_back(&#123;v, c, (int)adj[v].size()&#125;);    adj[v].push_back(&#123;u, 0, (int)adj[u].size() - 1&#125;); // 反向边容量0&#125;// BFS构建分层图bool bfs() &#123;    memset(level, -1\n","categories":["算法"],"tags":["图论"]},{"title":"C++ 算法竞赛模板","url":"/2025/12/11/C-%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B%E6%A8%A1%E6%9D%BF/","content":" 个人算法竞赛 C++ 常用模板\n 个人日常模板\n#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;climits&gt;#include &lt;cmath&gt;#include &lt;stack&gt;#include &lt;queue&gt;#include &lt;string&gt;#include &lt;cstdio&gt;#include &lt;chrono&gt;   #include &lt;map&gt;#include &lt;set&gt;#define F first#define S secondusing namespace std;typedef long long ll;typedef pair&lt;int, int&gt; pii;typedef pair&lt;ll, ll&gt; pll;// 常量定义const int INF = INT_MAX;const ll LLINF = LLONG_MAX;const int MOD = 1e9 + 7;const double PI = acos(-1.0);int dx4[4] = &#123;-1, 0, 1, 0&#125;, dy4[4] = &#123;0, 1, 0, -1&#125;;int dx8[8] = &#123;-1, -1, -1, 0, 1, 1, 1, 0&#125;, dy8[8] = &#123;-1, 0, 1, 1, 1, 0, -1, -1&#125;;int dxr[8] = &#123;-2, -1, 1, 2, 2, 1, -1, -2&#125;, dyr[8] = &#123;1, 2, 2, 1, -1, -2, -2, -1&#125;;inline void fast_io() &#123;    ios::sync_with_stdio(false);    cin.tie(nullptr);    cout.tie(nullptr);&#125;#define endl &#x27;\\n&#x27;#define all(x) (x).begin(), (x).end()#define rall(x) (x).rbegin(), (x).rend()#define x first#define y second#define pb push_back#define eb emplace_back#define debug(x) cerr &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; endl#define rep(i, a, b) for (int i = a; i &lt;= b; ++i)#define per(i, a, b) for (int i = a; i &gt;= b; --i)#define pb push_back#define mp make_pairconst int N = 1e5 + 10;void solve()&#123;    &#125;int main() &#123;    fast_io();      int tc; cin &gt;&gt; tc;      while(tc --) solve();    return 0;&#125;\n 相关算法模板\n#pragma once#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;climits&gt;#include &lt;cmath&gt;#include &lt;stack&gt;#include &lt;queue&gt;#include &lt;string&gt;#include &lt;cstdio&gt;#include &lt;chrono&gt;   // 计时所需#include &lt;map&gt;#include &lt;set&gt;using namespace std;// ====================== 基础配置 ======================typedef long long ll;typedef pair&lt;int, int&gt; pii;typedef pair&lt;ll, ll&gt; pll;// 常量定义const int INF = INT_MAX;const ll LLINF = LLONG_MAX;const int MOD = 1e9 + 7;const double PI = acos(-1.0);// 快速IO（必须调用）inline void fast_io() &#123;    ios::sync_with_stdio(false);    cin.tie(nullptr);    cout.tie(nullptr);&#125;// 循环宏（简化代码）#define FOR(i, a, b) for (int i = a; i &lt;= b; ++i)#define FORD(i, a, b) for (int i = a; i &gt;= b; --i)#define REP(i, n) for (int i = 0; i &lt; n; ++i)#define pb push_back#define mp make_pair// ====================== 通用Debug工具（核心新增） ======================namespace Debug &#123;    // 调试开关：提交前注释掉 #define DEBUG 即可关闭所有调试输出    #define DEBUG 1    // 基础变量打印（支持int/ll/double/string等）    template &lt;typename T&gt;    void print(const T&amp; val, const string&amp; name = &quot;&quot;) &#123;        #if DEBUG            if (!name.empty()) cout &lt;&lt; name &lt;&lt; &quot; = &quot;;            cout &lt;&lt; val &lt;&lt; endl;        #endif    &#125;    // 打印数组/vector（支持1-based/0-based）    template &lt;typename T&gt;    void print_vec(const vector&lt;T&gt;&amp; vec, const string&amp; name = &quot;&quot;, bool is_1based = true) &#123;        #if DEBUG            if (!name.empty()) cout &lt;&lt; name &lt;&lt; &quot;: &quot;;            int start = is_1based ? 1 : 0;            for (int i = start; i &lt; vec.size(); ++i) &#123;                cout &lt;&lt; vec[i] &lt;&lt; &quot; &quot;;            &#125;            cout &lt;&lt; endl;        #endif    &#125;    // 打印二维vector    template &lt;typename T&gt;    void print_2dvec(const vector&lt;vector&lt;T&gt;&gt;&amp; vec2d, const string&amp; name = &quot;&quot;) &#123;        #if DEBUG            if (!name.empty()) cout &lt;&lt; name &lt;&lt; &quot;:&quot; &lt;&lt; endl;            for (const auto&amp; vec : vec2d) &#123;                for (const auto&amp; val : vec) &#123;                    cout &lt;&lt; val &lt;&lt; &quot; &quot;;                &#125;                cout &lt;&lt; endl;            &#125;        #endif    &#125;    // 打印pair（如pii/pll）    template &lt;typename T1, typename T2&gt;    void print_pair(const pair&lt;T1, T2&gt;&amp; p, const string&amp; name = &quot;&quot;) &#123;        #if DEBUG            if (!name.empty()) cout &lt;&lt; name &lt;&lt; &quot; = &quot;;            cout &lt;&lt; &quot;(&quot; &lt;&lt; p.first &lt;&lt; &quot;, &quot; &lt;&lt; p.second &lt;&lt; &quot;)&quot; &lt;&lt; endl;        #endif    &#125;    // 打印map/set    template &lt;typename T&gt;    void print_set(const set&lt;T&gt;&amp; s, const string&amp; name = &quot;&quot;) &#123;        #if DEBUG            if (!name.empty()) cout &lt;&lt; name &lt;&lt; &quot;: &quot;;            for (const auto&amp; val : s) cout &lt;&lt; val &lt;&lt; &quot; &quot;;            cout &lt;&lt; endl;        #endif    &#125;    template &lt;typename K, typename V&gt;    void print_map(const map&lt;K, V&gt;&amp; m, const string&amp; name = &quot;&quot;) &#123;        #if DEBUG            if (!name.empty()) cout &lt;&lt; name &lt;&lt; &quot;:&quot; &lt;&lt; endl;            for (const auto&amp; [k, v] : m) cout &lt;&lt; k &lt;&lt; &quot; -&gt; &quot; &lt;&lt; v &lt;&lt; endl;        #endif    &#125;    // 计时工具：统计代码块执行时间（单位：毫秒）    class Timer &#123;    private:        chrono::high_resolution_clock::time_point start;        string name;    public:        Timer(const string&amp; timer_name = &quot;Code block&quot;) : name(timer_name) &#123;            #if DEBUG                start = chrono::high_resolution_clock::now();            #endif        &#125;        \\x7eTimer() &#123;            #if DEBUG                auto end = chrono::high_resolution_clock::now();                auto duration = chrono::duration_cast&lt;chrono::milliseconds&gt;(end - start).count();                cout &lt;&lt; &quot;[Timer] &quot; &lt;&lt; name &lt;&lt; &quot; executed in &quot; &lt;&lt; duration &lt;&lt; &quot; ms&quot; &lt;&lt; endl;            #endif        &#125;    &#125;;    // 分隔线：用于区分不同调试模块的输出    void separator(const string&amp; msg = &quot;&quot;) &#123;        #if DEBUG            cout &lt;&lt; &quot;===================== &quot; &lt;&lt; msg &lt;&lt; &quot; =====================&quot; &lt;&lt; endl;        #endif    &#125;&#125;// ====================== 数据结构 ======================// 1. 并查集（DSU）class DSU &#123;private:    vector&lt;int&gt; parent;    vector&lt;int&gt; rank;public:    DSU(int n) &#123;        parent.resize(n + 1); // 1-based        rank.resize(n + 1, 0);        FOR(i, 1, n) parent[i] = i;    &#125;    int find(int x) &#123; // 路径压缩        if (parent[x] != x) parent[x] = find(parent[x]);        return parent[x];    &#125;    void unite(int x, int y) &#123; // 按秩合并        x = find(x), y = find(y);        if (x == y) return;        if (rank[x] &lt; rank[y]) parent[x] = y;        else &#123;            parent[y] = x;            if (rank[x] == rank[y]) rank[x]++;        &#125;    &#125;    bool is_connected(int x, int y) &#123;        return find(x) == find(y);    &#125;&#125;;// 2. 线段树（单点更新 + 区间查询，支持求和/最大值/最小值）template &lt;typename T&gt;class SegmentTree &#123;private:    vector&lt;T&gt; tree;    int n;    T init_val; // 初始化值（求和=0，最大值=-INF，最小值=INF）    T (*merge)(T, T); // 合并函数    void build(int node, int l, int r, const vector&lt;T&gt;&amp; arr) &#123;        if (l == r) &#123;            tree[node] = arr[l];            return;        &#125;        int mid = (l + r) / 2;        build(2 * node, l, mid, arr);        build(2 * node + 1, mid + 1, r, arr);        tree[node] = merge(tree[2 * node], tree[2 * node + 1]);    &#125;    void update(int node, int l, int r, int pos, T val) &#123;        if (l == r) &#123;            tree[node] = val;            return;        &#125;        int mid = (l + r) / 2;        if (pos &lt;= mid) update(2 * node, l, mid, pos, val);        else update(2 * node + 1, mid + 1, r, pos, val);        tree[node] = merge(tree[2 * node], tree[2 * node + 1]);    &#125;    T query(int node, int l, int r, int ql, int qr) &#123;        if (qr &lt; l || ql &gt; r) return init_val;        if (ql &lt;= l &amp;&amp; r &lt;= qr) return tree[node];        int mid = (l + r) / 2;        return merge(query(2 * node, l, mid, ql, qr),                      query(2 * node + 1, mid + 1, r, ql, qr));    &#125;public:    // 构造函数：arr为1-based数组，merge_func为合并规则，init为初始值    SegmentTree(const vector&lt;T&gt;&amp; arr, T (*merge_func)(T, T), T init) &#123;        n = arr.size() - 1;        init_val = init;        merge = merge_func;        tree.resize(4 * (n + 1), init_val);        build(1, 1, n, arr);    &#125;    // 单点更新：pos为位置（1-based），val为新值    void update(int pos, T val) &#123;        update(1, 1, n, pos, val);    &#125;    // 区间查询：[ql, qr]（1-based）    T query(int ql, int qr) &#123;        return query(1, 1, n, ql, qr);    &#125;    // 预定义合并函数    static T sum(T a, T b) &#123; return a + b; &#125;    static T max_val(T a, T b) &#123; return max(a, b); &#125;    static T min_val(T a, T b) &#123; return min(a, b); &#125;&#125;;// 3. 单调栈（找下一个更大元素）vector&lt;int&gt; next_greater_element(vector&lt;int&gt;&amp; nums) &#123;    int n = nums.size();    vector&lt;int&gt; res(n, -1);    stack&lt;int&gt; st;    REP(i, n) &#123;        while (!st.empty() &amp;&amp; nums[i] &gt; nums[st.top()]) &#123;            res[st.top()] = nums[i];            st.pop();        &#125;        st.push(i);    &#125;    return res;&#125;// ====================== 图论 ======================// 1. Dijkstra（单源最短路径，正权边）vector&lt;ll&gt; dijkstra(int start, int n, const vector&lt;vector&lt;pii&gt;&gt;&amp; adj) &#123;    vector&lt;ll&gt; dist(n + 1, LLINF);    dist[start] = 0;    priority_queue&lt;pll, vector&lt;pll&gt;, greater&lt;pll&gt;&gt; pq;    pq.push(&#123;0, start&#125;);    while (!pq.empty()) &#123;        auto [d, u] = pq.top();        pq.pop();        if (d &gt; dist[u]) continue;        for (auto [v, w] : adj[u]) &#123;            if (dist[v] &gt; dist[u] + w) &#123;                dist[v] = dist[u] + w;                pq.push(&#123;dist[v], v&#125;);            &#125;        &#125;    &#125;    return dist;&#125;// ====================== 并查集（Kruskal依赖） ======================class DSU &#123;private:    vector&lt;int&gt; parent;    vector&lt;int&gt; rank;public:    DSU(int n) &#123;        parent.resize(n + 1); // 1-based        rank.resize(n + 1, 0);        for (int i = 1; i &lt;= n; ++i) parent[i] = i;    &#125;    int find(int x) &#123; // 路径压缩（递归版）        if (parent[x] != x) parent[x] = find(parent[x]);        return parent[x];    &#125;    bool unite(int x, int y) &#123; // 按秩合并，返回是否合并成功        x = find(x), y = find(y);        if (x == y) return false;        if (rank[x] &lt; rank[y]) parent[x] = y;        else &#123;            parent[y] = x;            if (rank[x] == rank[y]) rank[x]++;        &#125;        return true;    &#125;    bool is_connected(int x, int y) &#123;        return find(x) == find(y);    &#125;&#125;;// ====================== Kruskal算法核心 ======================struct Edge &#123;    int u, v;    // 边的两个端点（1-based）    ll w;        // 边的权值（用ll避免溢出）    // 重载&lt;，用于按权值升序排序（求最小生成树）    bool operator&lt;(const Edge&amp; rhs) const &#123;        return w &lt; rhs.w;    &#125;&#125;;// Kruskal算法求解最小生成树// 参数：n-节点数，edges-所有边的集合// 返回值：pair&lt;是否存在MST, MST的总权值&gt;pair&lt;bool, ll&gt; kruskal(int n, vector&lt;Edge&gt;&amp; edges) &#123;    // 1. 按边权升序排序（核心步骤）    sort(edges.begin(), edges.end());      // 2. 初始化并查集    DSU dsu(n);      ll mst_sum = 0; // MST的总权值    int edge_cnt = 0; // 已选入MST的边数      // 3. 遍历所有边，贪心选边    for (const Edge&amp; e : edges) &#123;        int u = e.u, v = e.v;        ll w = e.w;          // 若u和v不连通，则选这条边加入MST        if (dsu.unite(u, v)) &#123;            mst_sum += w;            edge_cnt++;            // 提前终止：MST需要n-1条边            if (edge_cnt == n - 1) break;        &#125;    &#125;      // 4. 判断是否存在MST（所有节点连通，即选够n-1条边）    bool has_mst = (edge_cnt == n - 1);    return &#123;has_mst, mst_sum&#125;;&#125;// ====================== 扩展：求最大生成树 ======================// 只需修改Edge的排序规则（降序）struct MaxEdge &#123;    int u, v;    ll w;    bool operator&lt;(const MaxEdge&amp; rhs) const &#123;        return w &gt; rhs.w; // 降序排序    &#125;&#125;;pair&lt;bool, ll&gt; kruskal_max(int n, vector&lt;MaxEdge&gt;&amp; edges) &#123;    sort(edges.begin(), edges.end());    DSU dsu(n);    ll mst_sum = 0;    int edge_cnt = 0;    for (const MaxEdge&amp; e : edges) &#123;        if (dsu.unite(e.u, e.v)) &#123;            mst_sum += e.w;            edge_cnt++;            if (edge_cnt == n - 1) break;        &#125;    &#125;    return &#123;edge_cnt == n - 1, mst_sum&#125;;&#125;// 2. 拓扑排序（Kahn算法，返回拓扑序，空表示有环）vector&lt;int&gt; topological_sort(int n, const vector&lt;vector&lt;int&gt;&gt;&amp; adj) &#123;    vector&lt;int&gt; in_degree(n + 1, 0);    FOR(u, 1, n) for (int v : adj[u]) in_degree[v]++;    queue&lt;int&gt; q;    FOR(u, 1, n) if (in_degree[u] == 0) q.push(u);    vector&lt;int&gt; res;    while (!q.empty()) &#123;        int u = q.front();        q.pop();        res.pb(u);        for (int v : adj[u]) &#123;            in_degree[v]--;            if (in_degree[v] == 0) q.push(v);        &#125;    &#125;    return res.size() == n ? res : vector&lt;int&gt;();&#125;// ====================== 数论 ======================// 1. 快速幂（含模）ll quick_pow(ll a, ll b, ll mod = MOD) &#123;    ll res = 1;    a %= mod;    while (b) &#123;        if (b &amp; 1) res = res * a % mod;        a = a * a % mod;        b &gt;&gt;= 1;    &#125;    return res;&#125;// 2. 欧拉筛（线性筛素数）vector&lt;int&gt; euler_sieve(int n) &#123;    vector&lt;bool&gt; is_prime(n + 1, true);    vector&lt;int&gt; primes;    is_prime[0] = is_prime[1] = false;    FOR(i, 2, n) &#123;        if (is_prime[i]) primes.pb(i);        for (int p : primes) &#123;            if (i * p &gt; n) break;            is_prime[i * p] = false;            if (i % p == 0) break;        &#125;    &#125;    return primes;&#125;// 3. 扩展欧几里得（解ax + by = gcd(a,b)）ll exgcd(ll a, ll b, ll&amp; x, ll&amp; y) &#123;    if (b == 0) &#123;        x = 1, y = 0;        return a;    &#125;    ll d = exgcd(b, a % b, y, x);    y -= a / b * x;    return d;&#125;// ====================== 动态规划 ======================// 1. 01背包（n件物品，容量m，v价值，w重量）ll knapsack_01(int n, int m, vector&lt;int&gt;&amp; v, vector&lt;int&gt;&amp; w) &#123;    vector&lt;ll&gt; dp(m + 1, 0);    FOR(i, 1, n) FORD(j, m, w[i])         dp[j] = max(dp[j], dp[j - w[i]] + v[i]);    return dp[m];&#125;// 2. 完全背包（物品可无限选）ll knapsack_complete(int n, int m, vector&lt;int&gt;&amp; v, vector&lt;int&gt;&amp; w) &#123;    vector&lt;ll&gt; dp(m + 1, 0);    FOR(i, 1, n) FOR(j, w[i], m)         dp[j] = max(dp[j], dp[j - w[i]] + v[i]);    return dp[m];&#125;// ====================== 字符串 ======================// KMP算法（模式匹配）namespace KMP &#123;    vector&lt;int&gt; get_next(const string&amp; pat) &#123;        int n = pat.size();        vector&lt;int&gt; nxt(n, 0);        int j = 0;        FOR(i, 1, n - 1) &#123;            while (j &gt; 0 &amp;&amp; pat[i] != pat[j]) j = nxt[j - 1];            if (pat[i] == pat[j]) j++;            nxt[i] = j;        &#125;        return nxt;    &#125;    vector&lt;int&gt; match(const string&amp; s, const string&amp; pat) &#123;        vector&lt;int&gt; nxt = get_next(pat);        vector&lt;int&gt; res;        int j = 0;        REP(i, s.size()) &#123;            while (j &gt; 0 &amp;&amp; s[i] != pat[j]) j = nxt[j - 1];            if (s[i] == pat[j]) j++;            if (j == pat.size()) &#123;                res.pb(i - j + 1);                j = nxt[j - 1];            &#125;        &#125;        return res;    &#125;&#125;#define For(i, a, b) for (int i = a; i &lt;= b; ++i)#define Ford(i, a, b) for (int i = a; i &gt;= b; --i)#define rep(i, n) for (int i = 0; i &lt; n; ++i)#define pb push_back#define mp make_pairconst int N = 1e5 + 10;int main() &#123;    fast_io();      return 0;&#125;\n","tags":["C++"]},{"title":"Luogu.局域网","url":"/2025/12/11/Luogu-%E5%B1%80%E5%9F%9F%E7%BD%91/","content":" Luogu 局域网\n 明确题意\n\n无向简单图，存在回路，不保证整张图属于连通图\n\n 分析思路\n\n要使得删除的网线的值最大，那么可以求出来整张图的最小生成树，然后使用存在变长之和 - 最小生成树的长度。\n\n 代码实现\n#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;climits&gt;#include &lt;cmath&gt;#include &lt;stack&gt;#include &lt;queue&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;chrono&gt;   #include &lt;map&gt;#include &lt;set&gt;#include &lt;bitset&gt;using namespace std;typedef long long ll;typedef pair&lt;int, int&gt; pii;typedef pair&lt;ll, ll&gt; pll;// const int INF = INT_MAX;const ll LLINF = LLONG_MAX;const int MOD = 1e9 + 7;const double PI = acos(-1.0);inline void fast_io() &#123;    ios::sync_with_stdio(false);    cin.tie(nullptr);    cout.tie(nullptr);&#125;#define For(i, a, b) for (int i = a; i &lt;= b; ++i)#define Ford(i, a, b) for (int i = a; i &gt;= b; --i)#define rep(i, n) for (int i = 0; i &lt; n; ++i)#define pb push_back#define mp make_pairconst int N = 1010, INF = 0x3f3f3f3f;int n, m, res;int g[N][N], d[N];bool st[N];void Prim()&#123;    memset(d, 0x3f, sizeof d);    memset(st, 0, sizeof st);    d[1] = 0;    rep(i, n)    &#123;        int x = 0;        For(j, 1, n)            if(!st[j] &amp;&amp; (!x || d[j] &lt; d[x])) x = j;        st[x] = 1;        // if(d[x] != INF) res += d[x];        For(j, 1, n)            if(!st[j]) d[j] = min(d[j], g[x][j]);    &#125;&#125;int main() &#123;    fast_io();    cin &gt;&gt; n &gt;&gt; m;    memset(g, 0x3f, sizeof g);    For(i, 1, n) g[i][i] = 0;    int sum = 0;    For(i, 1, m)    &#123;        int a, b, c; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;        g[a][b] = g[b][a] = min(g[a][b], c);        sum += c;    &#125;    Prim();    For(i, 1, n) if(d[i] &amp;&amp; d[i] != INF) res += d[i];    cout &lt;&lt; sum - res;    return 0;&#125;\n 避坑\n告诉图中的节点不保证联通，因此在使用 Prim 算法求解最小生成树的时候，在函数外面对 MST 中的边长进行统计的时候，一定要注意：第二个联通块的第一个节点的 d 数组的值会是 INF；\n那么，可以在函数内直接去计算加入到 MST 中边长的总和，最后使用图中所有边长总和 - MST 中边长即可。\n","categories":["最小生成树"],"tags":["图论"]},{"title":"快速幂，逆元与扩展欧几里得","url":"/2025/12/24/%E5%BF%AB%E9%80%9F%E5%B9%82%EF%BC%8C%E9%80%86%E5%85%83%E4%B8%8E%E6%89%A9%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97/","content":" 快速幂、逆元与线性同余方程\n 一、快速幂\n 1.1 问题背景\n常规计算  abmod  pa^b \\mod pabmodp  的方式是循环乘  bbb  次，时间复杂度为  O(b)O(b)O(b) 。当  bbb  达到  101810^{18}1018 时，该方法完全不可行。\n快速幂通过二进制分解指数，将时间复杂度降至O(log⁡b)O(\\log b)O(logb) ，是处理大指数幂运算的核心算法。\n 1.2 核心定理与推导\n 定理\n对于任意整数  a,b,pa, b, pa,b,p （ p&gt;0p&gt;0p&gt;0 ）， abmod  pa^b \\mod pabmodp  可通过分解  bbb  的二进制位，将幂运算转化为多次平方和乘法的组合。\n 推导思路\n\n\n二进制分解指数：任意正整数  bbb  可表示为二进制形式：\nb=c0×20+c1×21+c2×22+⋯+ck×2kb = c_0 \\times 2^0 + c_1 \\times 2^1 + c_2 \\times 2^2 + \\dots + c_k \\times 2^kb=c0​×20+c1​×21+c2​×22+⋯+ck​×2k, 其中  ci∈0,1c_i \\in {0,1}ci​∈0,1 ， k=⌊log⁡2b⌋k = \\lfloor \\log_2 b \\rfloork=⌊log2​b⌋ 。\n\n\n幂的拆分：根据幂的运算法则， ab=a∑i=0kci2i=∏i=0k(a2i)cia^b = a^{\\sum_{i=0}^k c_i 2^i} = \\prod_{i=0}^k (a^{2^i})^{c_i}ab=a∑i=0k​ci​2i=∏i=0k​(a2i)ci​ 。\n\n\n模运算性质： (a×b)mod  p=[(amod  p)×(bmod  p)]mod  p(a \\times b) \\mod p = [(a \\mod p) \\times (b \\mod p)] \\mod p(a×b)modp=[(amodp)×(bmodp)]modp ，因此每一步运算均可取模，避免数值溢出。\n\n\n 证明\n设  bbb  的二进制位为  c0c1…ckc_0c_1\\dots c_kc0​c1​…ck​ ，则：\n\n\n其中，若  ci=0c_i=0ci​=0 ，则该项为  111（不影响乘积）；若ci=1c_i=1ci​=1，则需将当前的a2ia^{2^i}a2i乘入结果。\n通过迭代计算  a2i=(a2i−1)2a^{2^i} = (a^{2^{i-1}})^2a2i=(a2i−1)2 （即每次将底数平方），并根据二进制位是否为  111决定是否乘入结果，最终得到abmod  pa^b \\mod pabmodp 。\n 1.3 代码实现\nll qmi(ll a, ll b, ll p){    ll res = 1;    while(b)    {        if(b &amp; 1) res = res * a % p;        a = a * a % p;        b &gt;&gt;= 1;    }    return res;}\n 1.4 复杂度分析\n\n时间复杂度： O(log⁡b)O(\\log b)O(logb) ，循环次数为指数  bbb  的二进制位数。\n空间复杂度： O(1)O(1)O(1) ，仅使用常数额外空间。\n\n 三、逆元的定义与存在性\n 2.1 逆元定义\n对于整数  aaa  和模数  ppp ，若存在整数  xxx  满足  a×x≡1(modp)a \\times x \\equiv 1 \\pmod{p}a×x≡1(modp) ，则称  xxx  为  aaa  在模  ppp  下的乘法逆元，记为  a−1mod  pa^{-1} \\mod pa−1modp 。\n 2.2 逆元存在的充要条件aaa  在模  ppp  下存在逆元的充要条件是  gcd⁡(a,p)=1\\gcd(a, p) = 1gcd(a,p)=1 （即  aaa  与  ppp  互质）。\n 证明\n\n必要性：若  aaa  存在逆元  xxx ，则  ax−1=kpa x - 1 = k pax−1=kp （ k∈Zk \\in \\mathbb{Z}k∈Z ），即  ax−kp=1a x - k p = 1ax−kp=1 。根据贝祖定理， gcd⁡(a,p)\\gcd(a, p)gcd(a,p)  必整除  111，故  gcd(a,p)=1gcd(a, p) = 1gcd(a,p)=1。\n充分性：若  gcd⁡(a,p)=1\\gcd(a, p) = 1gcd(a,p)=1 ，由贝祖定理，存在整数  x,yx, yx,y  使得  ax+py=1a x + p y = 1ax+py=1 。两边模  ppp  得  ax≡1(modp)a x \\equiv 1 \\pmod{p}ax≡1(modp) ，即  xxx  是  aaa  的逆元。\n\n 三、快速幂求解逆元（费马小定理）\n 3.1 前置定理：费马小定理\n若  ppp  是质数，且  gcd⁡(a,p)=1\\gcd(a, p) = 1gcd(a,p)=1 ，则  ap−1≡1(modp)a^{p-1} \\equiv 1 \\pmod{p}ap−1≡1(modp) 。\n 证明\n考虑模  ppp  的简化剩余系  1,2,…,p−1{1, 2, \\dots, p-1}1,2,…,p−1 ，由于  aaa  与  ppp  互质， a×1,a×2,…,a×(p−1){a \\times 1, a \\times 2, \\dots, a \\times (p-1)}a×1,a×2,…,a×(p−1)  也是模  ppp  的简化剩余系。因此：\n∏i=1p−1(a×i)≡∏i=1p−1i(modp)\\prod_{i=1}^{p-1} (a \\times i) \\equiv \\prod_{i=1}^{p-1} i \\pmod{p}∏i=1p−1​(a×i)≡∏i=1p−1​i(modp)\n左边提取  ap−1a^{p-1}ap−1 ，得  ap−1×∏i=1p−1i≡∏i=1p−1i(modp)a^{p-1} \\times \\prod_{i=1}^{p-1} i \\equiv \\prod_{i=1}^{p-1} i \\pmod{p}ap−1×∏i=1p−1​i≡∏i=1p−1​i(modp) 。由于  ∏i=1p−1i\\prod_{i=1}^{p-1} i∏i=1p−1​i  与  ppp  互质，两边可约去，故  ap−1≡1(modp)a^{p-1} \\equiv 1 \\pmod{p}ap−1≡1(modp) 。\n 3.2 快速幂求逆元的推导\n由费马小定理， ap−1≡1(modp)a^{p-1} \\equiv 1 \\pmod{p}ap−1≡1(modp) ，两边除以  aaa （等价于乘  a−1a^{-1}a−1 ）得：\nap−2≡a−1(modp)a^{p-2} \\equiv a^{-1} \\pmod{p}ap−2≡a−1(modp)\n因此，当  ppp  是质数且  gcd⁡(a,p)=1\\gcd(a, p)=1gcd(a,p)=1  时， aaa  的逆元为  ap−2mod  pa^{p-2} \\mod pap−2modp ，可通过快速幂直接计算。\n 3.3 代码实现（必要性：质数模数下快速求逆元）\n// p 为素数，并且 a 和 p 互质ll inv(ll a, ll p){    return qmi(a, p - 2, p);}\n 四、扩展欧几里得算法\n 4.1 问题背景\n欧几里得算法仅能求  gcd⁡(a,b)\\gcd(a, b)gcd(a,b) ，但扩展欧几里得算法（EXGCD）可在求  gcd⁡(a,b)\\gcd(a, b)gcd(a,b)  的同时，找到整数  x,yx, yx,y  满足贝祖等式：ax+by=gcd⁡(a,b)a x + b y = \\gcd(a, b)ax+by=gcd(a,b)。\n\n对于任意两个整数 aaa 和bbb ，设它们的最大公约数为d=gcd(a,b)d=gcd(a,b)d=gcd(a,b) ，则存在整数xxx 和d=gcd(a,b)d=gcd(a,b)d=gcd(a,b) ，使得： 其中，满足等式的整数对(x,y)(x,y)(x,y) 被称为贝祖系数。\n\n 4.2 算法推导与证明\n 核心思路\n基于欧几里得算法的递归过程： gcd⁡(a,b)=gcd⁡(b,amod  b)\\gcd(a, b) = \\gcd(b, a \\mod b)gcd(a,b)=gcd(b,amodb) ，反向推导  x,yx, yx,y  的值。\n 递归推导\n\n\n边界条件：当  b=0b = 0b=0  时， gcd⁡(a,0)=a\\gcd(a, 0) = agcd(a,0)=a ，此时贝祖等式为  a×1+0×0=aa \\times 1 + 0 \\times 0 = aa×1+0×0=a ，即  x=1,y=0x=1, y=0x=1,y=0 。\n\n\n递归步骤：假设已求得  gcd⁡(b,amod  b)\\gcd(b, a \\mod b)gcd(b,amodb)  对应的解  x′,y′x', y'x′,y′ ，即：\nbx′+(amod  b)y′=gcd⁡(a,b)b x' + (a \\mod b) y' = \\gcd(a, b)bx′+(amodb)y′=gcd(a,b)\n由于  amod  b=a−⌊ab⌋×ba \\mod b = a - \\lfloor \\frac{a}{b} \\rfloor \\times bamodb=a−⌊ba​⌋×b ，代入上式：\nbx′+(a−⌊ab⌋×b)y′=gcd⁡(a,b)b x' + (a - \\lfloor \\frac{a}{b} \\rfloor \\times b) y' = \\gcd(a, b)bx′+(a−⌊ba​⌋×b)y′=gcd(a,b)\n整理得：\nay′+b(x′−⌊ab⌋×y′)=gcd⁡(a,b)a y' + b (x' - \\lfloor \\frac{a}{b} \\rfloor \\times y') = \\gcd(a, b)ay′+b(x′−⌊ba​⌋×y′)=gcd(a,b)\n对比贝祖等式  ax+by=gcd⁡(a,b)a x + b y = \\gcd(a, b)ax+by=gcd(a,b) ，可得：\nx=y′,y=x′−⌊ab⌋×y′x = y', \\quad y = x' - \\lfloor \\frac{a}{b} \\rfloor \\times y'x=y′,y=x′−⌊ba​⌋×y′\n\n\n 证明（数学归纳法）\n\n基例： b=0b=0b=0  时，解为  x=1,y=0x=1, y=0x=1,y=0 ，显然满足  a×1+0×0=a=gcd⁡(a,0)a \\times 1 + 0 \\times 0 = a = \\gcd(a, 0)a×1+0×0=a=gcd(a,0) 。\n归纳假设：假设对于  (b,amod  b)(b, a \\mod b)(b,amodb) ，存在解  x′,y′x', y'x′,y′  满足  bx′+(amod  b)y′=gcd⁡(b,amod  b)b x' + (a \\mod b) y' = \\gcd(b, a \\mod b)bx′+(amodb)y′=gcd(b,amodb) 。\n归纳步骤：由上述推导， x=y′,y=x′−⌊ab⌋y′x=y', y=x' - \\lfloor \\frac{a}{b} \\rfloor y'x=y′,y=x′−⌊ba​⌋y′  满足  ax+by=gcd⁡(a,b)a x + b y = \\gcd(a, b)ax+by=gcd(a,b) ，故递归成立。\n\n 4.3 代码实现\nll exgcd(ll a, ll b, ll &amp;x, ll &amp;y){    if(!a &amp;&amp; !b) return -1;    if(!b) {x = 1, y = 0; return a;}    ll d = exgcd(b, a % b, y, x);    y -= a / b * x;    return d;}\n 五、扩展欧几里得求解逆元\n 5.1 推导思路\n逆元的定义是  ax≡1(modp)a x \\equiv 1 \\pmod{p}ax≡1(modp) ，即  ax−kp=1a x - k p = 1ax−kp=1 （ k∈Zk \\in \\mathbb{Z}k∈Z ）。令  y=−ky = -ky=−k ，则等式变为  ax+py=1a x + p y = 1ax+py=1 。\n由扩展欧几里得算法，当  gcd⁡(a,p)=1\\gcd(a, p)=1gcd(a,p)=1  时，可求得满足该等式的  x,yx, yx,y ，此时  xxx  即为  aaa  在模  ppp  下的逆元（若  xxx  为负数，需调整为正： x=(xmod  p+p)mod  px = (x \\mod p + p) \\mod px=(xmodp+p)modp ）。\n 5.2 求解步骤\n假设要求  aaa  在模  ppp  下的逆元，步骤如下：\n\n\n验证逆元存在性：计算  d=gcd⁡(a,p)d = \\gcd(a, p)d=gcd(a,p) ，若  d≠1d \\neq 1d=1 ，逆元不存在；\n\n\n调用扩展欧几里得算法：求解贝祖等式  ax+py=1a x + p y = 1ax+py=1 ，得到一组解  (x0,y0)(x_0, y_0)(x0​,y0​) ；\n\n\n调整逆元为正：扩展欧几里得得到的  x0x_0x0​  可能为负数，需将其调整到模  ppp  的正整数范围内：\nx=(x0mod  p+p)mod  px = (x_0 \\mod p + p) \\mod px=(x0​modp+p)modp\n\n\n 5.3 注意事项\n\n解的不唯一性：\n\n贝祖等式的解有无穷多组，若  (x0,y0)(x_0, y_0)(x0​,y0​)  是一组解，则所有解为：\nx=x0+k×pgcd⁡(a,p),y=y0−k×agcd⁡(a,p)(k∈Z)x = x_0 + k \\times \\frac{p}{\\gcd(a,p)}, \\quad y = y_0 - k \\times \\frac{a}{\\gcd(a,p)} \\quad (k \\in \\mathbb{Z})x=x0​+k×gcd(a,p)p​,y=y0​−k×gcd(a,p)a​(k∈Z)\n但模  ppp  下的逆元是唯一的（调整到  [0,p−1][0, p-1][0,p−1]  范围内后）。\n 5.4代码实现（必要性：非质数模数下求逆元）\nll exgcd(ll a, ll b, ll &amp;x, ll &amp;y){    if(b == 0) {x = 1; y = 0; return a;}    ll d = exgcd(b, a % b, y, x);    y -= a / b * x;    return d;}ll exgcd_inv(ll a, ll p){    ll x, y;    ll d = exgcd(a, p, x, y);    if(d != 1) return -1;    return (x % p + p) % p;}\n 六、线性求解 1 到 n 再质数模下的逆元\n如果需要求解  模 p 下的逆元时，如果逐个使用扩展欧几里得或者费马小定理，那么时间复杂度为O(nlog⁡p)O(n \\log p)O(nlogp)；而线性递推法可将时间复杂度降至O(n)O(n)O(n) ，是批量逆元求解的最优方法。\n 6.1 核心定理与递推公式\n设  ppp  为模数（通常为质数，保证   均与 ppp 互质），inv[i]$  表示  iii  在模  ppp 下的逆元，则递推公式为：\ninv[i]=(p−⌊pi⌋)×inv[pmod  i]mod  pinv[i] = (p - \\lfloor \\frac{p}{i} \\rfloor) \\times inv[p \\mod i] \\mod pinv[i]=(p−⌊ip​⌋)×inv[pmodi]modp\n初始条件： inv[1]=1inv[1] = 1inv[1]=1 （因为  ，1 的逆元恒为 1）。\n 6.2 公式推导（关键！）\n设  p=k×i+rp = k \\times i + rp=k×i+r （其中  k=⌊pi⌋k = \\lfloor \\frac{p}{i} \\rfloork=⌊ip​⌋ ， r=pmod  ir = p \\mod ir=pmodi ，满足  ），则：\nk×i+r≡0(modp)k \\times i + r \\equiv 0 \\pmod{p}k×i+r≡0(modp)\n两边同时乘  inv[i]×inv[r]inv[i] \\times inv[r]inv[i]×inv[r] （逆元存在，因为  i,r&lt;pi, r &lt; pi,r&lt;p  且  ppp  为质数），得：\nk×inv[r]+inv[i]≡0(modp)k \\times inv[r] + inv[i] \\equiv 0 \\pmod{p}k×inv[r]+inv[i]≡0(modp)\n移项后：\ninv[i]≡−k×inv[r](modp)inv[i] \\equiv -k \\times inv[r] \\pmod{p}inv[i]≡−k×inv[r](modp)\n将  k=⌊pi⌋k = \\lfloor \\frac{p}{i} \\rfloork=⌊ip​⌋ 、 r=pmod  ir = p \\mod ir=pmodi  代入，且为避免负数，将  −k-k−k  替换为  p−kp - kp−k （模  ppp  下等价），最终得到：\ninv[i]=(p−⌊pi⌋)×inv[pmod  i]mod  pinv[i] = (p - \\lfloor \\frac{p}{i} \\rfloor) \\times inv[p \\mod i] \\mod pinv[i]=(p−⌊ip​⌋)×inv[pmodi]modp\n 6.3 代码实现\nint inv[N];void invEle(ll n, ll p){\tinv[1] = 1;\tfor (int i = 2; i &lt;= n; i ++)         inv[i] = (p - p / i) * inv[p % i] % p;}\n 七、线性同余方程求解\n 7.1 线性同余方程定义\n形如  ax≡b(modp)a x \\equiv b \\pmod{p}ax≡b(modp)  的方程称为线性同余方程，其中  a,b,pa, b, pa,b,p  为已知整数， xxx  为未知整数。\n 7.2 方程有解的充要条件\n线性同余方程  ax≡b(modp)a x \\equiv b \\pmod{p}ax≡b(modp)  有解的充要条件是  gcd⁡(a,p)∣b\\gcd(a, p) \\mid bgcd(a,p)∣b （即  bbb  能被  aaa  和  ppp  的最大公约数整除）。\n 证明\n\n必要性： ax≡b(modp)a x \\equiv b \\pmod{p}ax≡b(modp)  等价于  ax−kp=ba x - k p = bax−kp=b （ k∈Zk \\in \\mathbb{Z}k∈Z ）。由贝祖定理， gcd⁡(a,p)\\gcd(a, p)gcd(a,p)  必整除  bbb 。\n充分性：若  gcd⁡(a,p)=d\\gcd(a, p) = dgcd(a,p)=d  且  d∣bd \\mid bd∣b ，令  a′=a/d,b′=b/d,p′=p/da' = a/d, b' = b/d, p' = p/da′=a/d,b′=b/d,p′=p/d ，则方程变为  a′x≡b′(modp′)a' x \\equiv b' \\pmod{p'}a′x≡b′(modp′) 。此时  gcd⁡(a′,p′)=1\\gcd(a', p') = 1gcd(a′,p′)=1 ， a′a'a′  存在逆元  a′−1a'^{-1}a′−1 ，故解为  x≡a′−1×b′(modp′)x \\equiv a'^{-1} \\times b' \\pmod{p'}x≡a′−1×b′(modp′) 。\n\n 7.3 求解步骤\n\n计算  d=gcd⁡(a,p)d = \\gcd(a, p)d=gcd(a,p) ，若  bmod  d≠0b \\mod  d \\neq 0bmodd=0 ，方程无解；\n化简方程：两边除以  ddd ，得  a′x≡b′(modp′)a' x \\equiv b' \\pmod{p'}a′x≡b′(modp′) （ a′=a/d,b′=b/d,p′=p/da'=a/d, b'=b/d, p'=p/da′=a/d,b′=b/d,p′=p/d ）；\n求  a′a'a′  在模  p′p'p′  下的逆元  invinvinv （扩展欧几里得/快速幂）；\n特解： x0=(b′×inv)mod  p′x_0 = (b' \\times inv) \\mod p'x0​=(b′×inv)modp′ ；\n通解： x=x0+k×p′x = x_0 + k \\times p'x=x0​+k×p′ （ k∈Zk \\in \\mathbb{Z}k∈Z ），模  ppp  下的所有解为  x0,x0+p′,x0+2p′,…,x0+(d−1)p′x_0, x_0+p', x_0+2p', \\dots, x_0+(d-1)p'x0​,x0​+p′,x0​+2p′,…,x0​+(d−1)p′ 。\n\n 7.4 代码实现\n#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;climits&gt;#include &lt;cmath&gt;#include &lt;stack&gt;#include &lt;queue&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;chrono&gt;   #include &lt;map&gt;#include &lt;set&gt;#include &lt;bitset&gt;using namespace std;typedef long long ll;typedef pair&lt;int, int&gt; pii;typedef pair&lt;ll, ll&gt; pll;const int INF = INT_MAX;const ll LLINF = LLONG_MAX;const int MOD = 1e9 + 7;const double PI = acos(-1.0);inline void fast_io() {    ios::sync_with_stdio(false);    cin.tie(nullptr);    cout.tie(nullptr);}#define For(i, a, b) for (int i = a; i &lt;= b; ++i)#define Ford(i, a, b) for (int i = a; i &gt;= b; --i)#define rep(i, n) for (int i = 0; i &lt; n; ++i)#define pb push_back#define mp make_pairconst int N = 1e6 + 10;ll exgcd(ll a, ll b, ll &amp;x, ll &amp;y){    if(!b) {x = 1; y = 0; return a;}    ll d = exgcd(b, a % b, y, x);    y -= a / b * x;    return d;}int main() {    fast_io();    int tc; cin &gt;&gt; tc;    while(tc --)    {        ll a, b, m; cin &gt;&gt; a &gt;&gt; b &gt;&gt; m;        ll x, y;        ll d = exgcd(a, m, x, y);            if(b % d != 0) {            cout &lt;&lt; \"impossible\\n\";            continue;        }            // 化简方程：a/d * x ≡ b/d (mod m/d)        ll m_div = m / d;           ll a_div = a / d;        ll b_div = b / d;            ll ans = (b_div * x) % m_div;        while(ans &lt; 0) ans += m_div;            cout &lt;&lt; ans &lt;&lt; \"\\n\";    }    return 0;}\n 7.5 复杂度分析\n\n核心步骤为扩展欧几里得算法，时间复杂度  O(log⁡min⁡(a,p))O(\\log \\min(a,p))O(logmin(a,p)) ；\n通解生成的时间复杂度为  O(d)O(d)O(d) （ d=gcd⁡(a,p)d=\\gcd(a,p)d=gcd(a,p) ），通常可忽略\n\n","categories":["算法"],"tags":["数论","快速幂","扩展欧几里得","逆元"]}]