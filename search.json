[{"title":"快速幂，逆元与扩展欧几里得","url":"/2025/12/24/快速幂，逆元与扩展欧几里得/","content":"\n\n# 快速幂、逆元与线性同余方程\n\n## 一、快速幂\n\n### 1.1 问题背景\n\n常规计算  $a^b \\mod p$  的方式是循环乘  $b$  次，时间复杂度为  $O(b)$ 。当  $b$  达到  $10^{18}$ 时，该方法完全不可行。\n\n快速幂通过**二进制分解指数**，将时间复杂度降至$O(\\log b)$ ，是处理大指数幂运算的核心算法。\n\n### 1.2 核心定理与推导\n\n#### 定理\n\n对于任意整数  $a, b, p$ （ $p>0$ ）， $a^b \\mod p$  可通过分解  $b$  的二进制位，将幂运算转化为多次平方和乘法的组合。\n\n#### 推导思路\n\n1. 二进制分解指数：任意正整数  $b$  可表示为二进制形式：\n   \n   $b = c_0 \\times 2^0 + c_1 \\times 2^1 + c_2 \\times 2^2 + \\dots + c_k \\times 2^k$, 其中  $c_i \\in {0,1}$ ， $k = \\lfloor \\log_2 b \\rfloor$ 。\n2. 幂的拆分：根据幂的运算法则， $a^b = a^{\\sum_{i=0}^k c_i 2^i} = \\prod_{i=0}^k (a^{2^i})^{c_i}$ 。\n3. 模运算性质： $(a \\times b) \\mod p = [(a \\mod p) \\times (b \\mod p)] \\mod p$ ，因此每一步运算均可取模，避免数值溢出。\n\n#### 证明\n\n设  $b$  的二进制位为  $c_0c_1\\dots c_k$ ，则：\n\n$$\n\\begin{align*}\na^b &= a^{c_0 \\times 2^0 + c_1 \\times 2^1 + \\dots + c_k \\times 2^k} \\\\\n    &= a^{c_0 \\times 2^0} \\times a^{c_1 \\times 2^1} \\times \\dots \\times a^{c_k \\times 2^k} \\\\\n    &= \\left(a^{2^0}\\right)^{c_0} \\times \\left(a^{2^1}\\right)^{c_1} \\times \\dots \\times \\left(a^{2^k}\\right)^{c_k}\n\\end{align*}\n$$\n\n其中，若  $c_i=0$ ，则该项为  $1$（不影响乘积）；若$c_i=1$，则需将当前的$a^{2^i}$乘入结果。\n\n通过迭代计算  $a^{2^i} = (a^{2^{i-1}})^2$ （即每次将底数平方），并根据二进制位是否为  $1$决定是否乘入结果，最终得到$a^b \\mod p$ 。\n\n### 1.3 代码实现\n\n```cpp\nll qmi(ll a, ll b, ll p)\n{\n    ll res = 1;\n    while(b)\n    {\n        if(b & 1) res = res * a % p;\n        a = a * a % p;\n        b >>= 1;\n    }\n    return res;\n}\n```\n\n### 1.4 复杂度分析\n\n* 时间复杂度： $O(\\log b)$ ，循环次数为指数  $b$  的二进制位数。\n* 空间复杂度： $O(1)$ ，仅使用常数额外空间。\n\n## 三、逆元的定义与存在性\n\n### 2.1 逆元定义\n\n对于整数  $a$  和模数  $p$ ，若存在整数  $x$  满足  $a \\times x \\equiv 1 \\pmod{p}$ ，则称  $x$  为  $a$  在模  $p$  下的**乘法逆元**，记为  $a^{-1} \\mod p$ 。\n\n### 2.2 逆元存在的充要条件$a$  在模  $p$  下存在逆元的充要条件是  $\\gcd(a, p) = 1$ （即  $a$  与  $p$  互质）。\n\n#### 证明\n\n* 必要性：若  $a$  存在逆元  $x$ ，则  $a x - 1 = k p$ （ $k \\in \\mathbb{Z}$ ），即  $a x - k p = 1$ 。根据贝祖定理， $\\gcd(a, p)$  必整除  $1$，故  $gcd(a, p) = 1$。\n* 充分性：若  $\\gcd(a, p) = 1$ ，由贝祖定理，存在整数  $x, y$  使得  $a x + p y = 1$ 。两边模  $p$  得  $a x \\equiv 1 \\pmod{p}$ ，即  $x$  是  $a$  的逆元。\n\n## 三、快速幂求解逆元（费马小定理）\n\n### 3.1 前置定理：费马小定理\n\n若  $p$  是质数，且  $\\gcd(a, p) = 1$ ，则  $a^{p-1} \\equiv 1 \\pmod{p}$ 。\n\n#### 证明\n\n考虑模  $p$  的简化剩余系  ${1, 2, \\dots, p-1}$ ，由于  $a$  与  $p$  互质， ${a \\times 1, a \\times 2, \\dots, a \\times (p-1)}$  也是模  $p$  的简化剩余系。因此：\n\n$\\prod_{i=1}^{p-1} (a \\times i) \\equiv \\prod_{i=1}^{p-1} i \\pmod{p}$\n\n左边提取  $a^{p-1}$ ，得  $a^{p-1} \\times \\prod_{i=1}^{p-1} i \\equiv \\prod_{i=1}^{p-1} i \\pmod{p}$ 。由于  $\\prod_{i=1}^{p-1} i$  与  $p$  互质，两边可约去，故  $a^{p-1} \\equiv 1 \\pmod{p}$ 。\n\n### 3.2 快速幂求逆元的推导\n\n由费马小定理， $a^{p-1} \\equiv 1 \\pmod{p}$ ，两边除以  $a$ （等价于乘  $a^{-1}$ ）得：\n\n$a^{p-2} \\equiv a^{-1} \\pmod{p}$\n\n因此，当  $p$  是质数且  $\\gcd(a, p)=1$  时， $a$  的逆元为  $a^{p-2} \\mod p$ ，可通过快速幂直接计算。\n\n### 3.3 代码实现（必要性：质数模数下快速求逆元）\n\n```cpp\n// p 为素数，并且 a 和 p 互质\nll inv(ll a, ll p)\n{\n    return qmi(a, p - 2, p);\n}\n```\n\n## 四、扩展欧几里得算法\n\n### 4.1 问题背景\n\n欧几里得算法仅能求  $\\gcd(a, b)$ ，但扩展欧几里得算法（EXGCD）可在求  $\\gcd(a, b)$  的同时，找到整数  $x, y$  满足贝祖等式：$a x + b y = \\gcd(a, b)$。\n\n> 对于任意两个整数 $a$ 和$b$ ，设它们的最大公约数为$d=gcd(a,b)$ ，则**存在整数**$x$**&#x20;和**$d=gcd(a,b)$**&#x20;**，使得：$ax+by=d $ 其中，满足等式的整数对$(x,y)$ 被称为**贝祖系数**。\n\n### 4.2 算法推导与证明\n\n#### 核心思路\n\n基于欧几里得算法的递归过程： $\\gcd(a, b) = \\gcd(b, a \\mod b)$ ，反向推导  $x, y$  的值。\n\n#### 递归推导\n\n1. 边界条件：当  $b = 0$  时， $\\gcd(a, 0) = a$ ，此时贝祖等式为  $a \\times 1 + 0 \\times 0 = a$ ，即  $x=1, y=0$ 。\n2. 递归步骤：假设已求得  $\\gcd(b, a \\mod b)$  对应的解  $x', y'$ ，即：\n   \n   $b x' + (a \\mod b) y' = \\gcd(a, b)$\n   \n   由于  $a \\mod b = a - \\lfloor \\frac{a}{b} \\rfloor \\times b$ ，代入上式：\n   \n   $b x' + (a - \\lfloor \\frac{a}{b} \\rfloor \\times b) y' = \\gcd(a, b)$\n   \n   整理得：\n   \n   $a y' + b (x' - \\lfloor \\frac{a}{b} \\rfloor \\times y') = \\gcd(a, b)$\n   \n   对比贝祖等式  $a x + b y = \\gcd(a, b)$ ，可得：\n   \n   $x = y', \\quad y = x' - \\lfloor \\frac{a}{b} \\rfloor \\times y'$\n\n#### 证明（数学归纳法）\n\n* 基例： $b=0$  时，解为  $x=1, y=0$ ，显然满足  $a \\times 1 + 0 \\times 0 = a = \\gcd(a, 0)$ 。\n* 归纳假设：假设对于  $(b, a \\mod b)$ ，存在解  $x', y'$  满足  $b x' + (a \\mod b) y' = \\gcd(b, a \\mod b)$ 。\n* 归纳步骤：由上述推导， $x=y', y=x' - \\lfloor \\frac{a}{b} \\rfloor y'$  满足  $a x + b y = \\gcd(a, b)$ ，故递归成立。\n\n### 4.3 代码实现\n\n```cpp\nll exgcd(ll a, ll b, ll &x, ll &y)\n{\n    if(!a && !b) return -1;\n    if(!b) {x = 1, y = 0; return a;}\n    ll d = exgcd(b, a % b, y, x);\n    y -= a / b * x;\n    return d;\n}\n```\n\n## 五、扩展欧几里得求解逆元\n\n### 5.1 推导思路\n\n逆元的定义是  $a x \\equiv 1 \\pmod{p}$ ，即  $a x - k p = 1$ （ $k \\in \\mathbb{Z}$ ）。令  $y = -k$ ，则等式变为  $a x + p y = 1$ 。\n\n由扩展欧几里得算法，当  $\\gcd(a, p)=1$  时，可求得满足该等式的  $x, y$ ，此时  $x$  即为  $a$  在模  $p$  下的逆元（若  $x$  为负数，需调整为正： $x = (x \\mod p + p) \\mod p$ ）。\n\n### 5.2 求解步骤\n\n假设要求  $a$  在模  $p$  下的逆元，步骤如下：\n\n1. **验证逆元存在性**：计算  $d = \\gcd(a, p)$ ，若  $d \\neq 1$ ，逆元不存在；\n2. **调用扩展欧几里得算法**：求解贝祖等式  $a x + p y = 1$ ，得到一组解  $(x_0, y_0)$ ；\n3. **调整逆元为正**：扩展欧几里得得到的  $x_0$  可能为负数，需将其调整到模  $p$  的正整数范围内：\n   \n   $x = (x_0 \\mod p + p) \\mod p$\n\n### 5.3 注意事项\n\n1. **解的不唯一性**：\n\n贝祖等式的解有无穷多组，若  $(x_0, y_0)$  是一组解，则所有解为：\n\n$x = x_0 + k \\times \\frac{p}{\\gcd(a,p)}, \\quad y = y_0 - k \\times \\frac{a}{\\gcd(a,p)} \\quad (k \\in \\mathbb{Z})$\n\n但模  $p$  下的逆元是唯一的（调整到  $[0, p-1]$  范围内后）。\n\n### 5.4代码实现（必要性：非质数模数下求逆元）\n\n```cpp\nll exgcd(ll a, ll b, ll &x, ll &y)\n{\n    if(b == 0) {x = 1; y = 0; return a;}\n    ll d = exgcd(b, a % b, y, x);\n    y -= a / b * x;\n    return d;\n}\n\nll exgcd_inv(ll a, ll p)\n{\n    ll x, y;\n    ll d = exgcd(a, p, x, y);\n    if(d != 1) return -1;\n    return (x % p + p) % p;\n}\n```\n\n## 六、线性求解 1 到 n 再质数模下的逆元\n\n如果需要求解$ 1 \\sim n$  模 p 下的逆元时，如果逐个使用扩展欧几里得或者费马小定理，那么时间复杂度为$O(n \\log p)$；而**线性递推法**可将时间复杂度降至$O(n)$ ，是批量逆元求解的最优方法。\n\n#### 6.1 核心定理与递推公式\n\n设  $p$  为模数（通常为质数，保证  $ 1 \\sim n$ 均与 $p$ 互质），inv\\[i]$  表示  $i$  在模  $p$ 下的逆元，则递推公式为：\n\n$inv[i] = (p - \\lfloor \\frac{p}{i} \\rfloor) \\times inv[p \\mod i] \\mod p$\n\n**初始条件**： $inv[1] = 1$ （因为 $ 1 \\times 1 \\equiv 1 \\pmod{p}$ ，1 的逆元恒为 1）。\n\n#### 6.2 公式推导（关键！）\n\n设  $p = k \\times i + r$ （其中  $k = \\lfloor \\frac{p}{i} \\rfloor$ ， $r = p \\mod i$ ，满足 $ 0 < r < i$ ），则：\n\n$k \\times i + r \\equiv 0 \\pmod{p}$\n\n两边同时乘  $inv[i] \\times inv[r]$ （逆元存在，因为  $i, r < p$  且  $p$  为质数），得：\n\n$k \\times inv[r] + inv[i] \\equiv 0 \\pmod{p}$\n\n移项后：\n\n$inv[i] \\equiv -k \\times inv[r] \\pmod{p}$\n\n将  $k = \\lfloor \\frac{p}{i} \\rfloor$ 、 $r = p \\mod i$  代入，且为避免负数，将  $-k$  替换为  $p - k$ （模  $p$  下等价），最终得到：\n\n$inv[i] = (p - \\lfloor \\frac{p}{i} \\rfloor) \\times inv[p \\mod i] \\mod p$\n\n### 6.3 代码实现\n\n```cpp\nint inv[N];\n\nvoid invEle(ll n, ll p)\n{\n\tinv[1] = 1;\n\tfor (int i = 2; i <= n; i ++) \n        inv[i] = (p - p / i) * inv[p % i] % p;\n}\n```\n\n## 七、线性同余方程求解\n\n### 7.1 线性同余方程定义\n\n形如  $a x \\equiv b \\pmod{p}$  的方程称为**线性同余方程**，其中  $a, b, p$  为已知整数， $x$  为未知整数。\n\n### 7.2 方程有解的充要条件\n\n线性同余方程  $a x \\equiv b \\pmod{p}$  有解的充要条件是  $\\gcd(a, p) \\mid b$ （即  $b$  能被  $a$  和  $p$  的最大公约数整除）。\n\n#### 证明\n\n* 必要性： $a x \\equiv b \\pmod{p}$  等价于  $a x - k p = b$ （ $k \\in \\mathbb{Z}$ ）。由贝祖定理， $\\gcd(a, p)$  必整除  $b$ 。\n* 充分性：若  $\\gcd(a, p) = d$  且  $d \\mid b$ ，令  $a' = a/d, b' = b/d, p' = p/d$ ，则方程变为  $a' x \\equiv b' \\pmod{p'}$ 。此时  $\\gcd(a', p') = 1$ ， $a'$  存在逆元  $a'^{-1}$ ，故解为  $x \\equiv a'^{-1} \\times b' \\pmod{p'}$ 。\n\n### 7.3 求解步骤\n\n1. 计算  $d = \\gcd(a, p)$ ，若  $b \\mod  d \\neq 0$ ，方程无解；\n2. 化简方程：两边除以  $d$ ，得  $a' x \\equiv b' \\pmod{p'}$ （ $a'=a/d, b'=b/d, p'=p/d$ ）；\n3. 求  $a'$  在模  $p'$  下的逆元  $inv$ （扩展欧几里得/快速幂）；\n4. 特解： $x_0 = (b' \\times inv) \\mod p'$ ；\n5. 通解： $x = x_0 + k \\times p'$ （ $k \\in \\mathbb{Z}$ ），模  $p$  下的所有解为  $x_0, x_0+p', x_0+2p', \\dots, x_0+(d-1)p'$ 。\n\n### 7.4 代码实现\n\n```cpp\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <climits>\n#include <cmath>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <cstdio>\n#include <chrono>   \n#include <map>\n#include <set>\n#include <bitset>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int INF = INT_MAX;\nconst ll LLINF = LLONG_MAX;\nconst int MOD = 1e9 + 7;\nconst double PI = acos(-1.0);\n\ninline void fast_io() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout.tie(nullptr);\n}\n\n#define For(i, a, b) for (int i = a; i <= b; ++i)\n#define Ford(i, a, b) for (int i = a; i >= b; --i)\n#define rep(i, n) for (int i = 0; i < n; ++i)\n#define pb push_back\n#define mp make_pair\n\nconst int N = 1e6 + 10;\n\nll exgcd(ll a, ll b, ll &x, ll &y)\n{\n    if(!b) {x = 1; y = 0; return a;}\n    ll d = exgcd(b, a % b, y, x);\n    y -= a / b * x;\n    return d;\n}\n\nint main() {\n    fast_io();\n    int tc; cin >> tc;\n    while(tc --)\n    {\n        ll a, b, m; cin >> a >> b >> m;\n        ll x, y;\n        ll d = exgcd(a, m, x, y);\n    \n        if(b % d != 0) {\n            cout << \"impossible\\n\";\n            continue;\n        }\n    \n        // 化简方程：a/d * x ≡ b/d (mod m/d)\n        ll m_div = m / d;   \n        ll a_div = a / d;\n        ll b_div = b / d;\n    \n        ll ans = (b_div * x) % m_div;\n        while(ans < 0) ans += m_div;\n    \n        cout << ans << \"\\n\";\n    }\n    return 0;\n}\n```\n\n### 7.5 复杂度分析\n\n* 核心步骤为扩展欧几里得算法，时间复杂度  $O(\\log \\min(a,p))$ ；\n* 通解生成的时间复杂度为  $O(d)$ （ $d=\\gcd(a,p)$ ），通常可忽略\n\n\n","tags":["数论","快速幂","扩展欧几里得","逆元"],"categories":["算法"]},{"title":"Luogu.局域网","url":"/2025/12/11/Luogu-局域网/","content":"# Luogu 局域网\n\n## 明确题意\n\n1. 无向简单图，存在回路，**不保证整张图属于连通图**\n\n## 分析思路\n\n1. 要使得删除的网线的值最大，那么可以求出来整张图的最小生成树，然后使用存在变长之和 - 最小生成树的长度。\n\n## 代码实现\n\n```cpp\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <climits>\n#include <cmath>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <cstdio>\n#include <chrono>   \n#include <map>\n#include <set>\n#include <bitset>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\n// const int INF = INT_MAX;\nconst ll LLINF = LLONG_MAX;\nconst int MOD = 1e9 + 7;\nconst double PI = acos(-1.0);\n\ninline void fast_io() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout.tie(nullptr);\n}\n\n#define For(i, a, b) for (int i = a; i <= b; ++i)\n#define Ford(i, a, b) for (int i = a; i >= b; --i)\n#define rep(i, n) for (int i = 0; i < n; ++i)\n#define pb push_back\n#define mp make_pair\n\nconst int N = 1010, INF = 0x3f3f3f3f;\nint n, m, res;\nint g[N][N], d[N];\nbool st[N];\n\nvoid Prim()\n{\n    memset(d, 0x3f, sizeof d);\n    memset(st, 0, sizeof st);\n\n    d[1] = 0;\n    rep(i, n)\n    {\n        int x = 0;\n        For(j, 1, n)\n            if(!st[j] && (!x || d[j] < d[x])) x = j;\n        st[x] = 1;\n        // if(d[x] != INF) res += d[x];\n        For(j, 1, n)\n            if(!st[j]) d[j] = min(d[j], g[x][j]);\n    }\n}\nint main() {\n    fast_io();\n    cin >> n >> m;\n    memset(g, 0x3f, sizeof g);\n    For(i, 1, n) g[i][i] = 0;\n    int sum = 0;\n    For(i, 1, m)\n    {\n        int a, b, c; cin >> a >> b >> c;\n        g[a][b] = g[b][a] = min(g[a][b], c);\n        sum += c;\n    }\n    Prim();\n    For(i, 1, n) if(d[i] && d[i] != INF) res += d[i];\n    cout << sum - res;\n    return 0;\n}\n```\n\n## 避坑\n\n告诉图中的节点不保证联通，因此在使用 Prim 算法求解最小生成树的时候，在函数外面对 MST 中的边长进行统计的时候，一定要注意：第二个联通块的第一个节点的 d 数组的值会是 INF；\n\n那么，可以在函数内直接去计算加入到 MST 中边长的总和，最后使用图中所有边长总和 - MST 中边长即可。","tags":["图论"],"categories":["最小生成树"]},{"title":"C++ 算法竞赛模板","url":"/2025/12/11/C-算法竞赛模板/","content":"# 个人算法竞赛 C++ 常用模板\n\n\n## 个人日常模板\n\n```cpp\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <climits>\n#include <cmath>\n#include <stack>\n#include <queue>\n#include <string>\n#include <cstdio>\n#include <chrono>   \n#include <map>\n#include <set>\n#define F first\n#define S second\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\n// 常量定义\nconst int INF = INT_MAX;\nconst ll LLINF = LLONG_MAX;\nconst int MOD = 1e9 + 7;\nconst double PI = acos(-1.0);\n\nint dx4[4] = {-1, 0, 1, 0}, dy4[4] = {0, 1, 0, -1};\nint dx8[8] = {-1, -1, -1, 0, 1, 1, 1, 0}, dy8[8] = {-1, 0, 1, 1, 1, 0, -1, -1};\nint dxr[8] = {-2, -1, 1, 2, 2, 1, -1, -2}, dyr[8] = {1, 2, 2, 1, -1, -2, -2, -1};\n\ninline void fast_io() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout.tie(nullptr);\n}\n\n#define endl '\\n'\n#define all(x) (x).begin(), (x).end()\n#define rall(x) (x).rbegin(), (x).rend()\n#define x first\n#define y second\n#define pb push_back\n#define eb emplace_back\n#define debug(x) cerr << #x << \" = \" << x << endl\n#define rep(i, a, b) for (int i = a; i <= b; ++i)\n#define per(i, a, b) for (int i = a; i >= b; --i)\n#define pb push_back\n#define mp make_pair\n\nconst int N = 1e5 + 10;\n\nvoid solve()\n{\n    \n}\n\nint main() {\n    fast_io();\n      int tc; cin >> tc;\n      while(tc --) solve();\n    return 0;\n}\n```\n\n\n## 相关算法模板\n\n```cpp\n#pragma once\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <climits>\n#include <cmath>\n#include <stack>\n#include <queue>\n#include <string>\n#include <cstdio>\n#include <chrono>   // 计时所需\n#include <map>\n#include <set>\nusing namespace std;\n\n// ====================== 基础配置 ======================\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\n// 常量定义\nconst int INF = INT_MAX;\nconst ll LLINF = LLONG_MAX;\nconst int MOD = 1e9 + 7;\nconst double PI = acos(-1.0);\n\n// 快速IO（必须调用）\ninline void fast_io() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout.tie(nullptr);\n}\n\n// 循环宏（简化代码）\n#define FOR(i, a, b) for (int i = a; i <= b; ++i)\n#define FORD(i, a, b) for (int i = a; i >= b; --i)\n#define REP(i, n) for (int i = 0; i < n; ++i)\n#define pb push_back\n#define mp make_pair\n\n// ====================== 通用Debug工具（核心新增） ======================\nnamespace Debug {\n    // 调试开关：提交前注释掉 #define DEBUG 即可关闭所有调试输出\n    #define DEBUG 1\n\n    // 基础变量打印（支持int/ll/double/string等）\n    template <typename T>\n    void print(const T& val, const string& name = \"\") {\n        #if DEBUG\n            if (!name.empty()) cout << name << \" = \";\n            cout << val << endl;\n        #endif\n    }\n\n    // 打印数组/vector（支持1-based/0-based）\n    template <typename T>\n    void print_vec(const vector<T>& vec, const string& name = \"\", bool is_1based = true) {\n        #if DEBUG\n            if (!name.empty()) cout << name << \": \";\n            int start = is_1based ? 1 : 0;\n            for (int i = start; i < vec.size(); ++i) {\n                cout << vec[i] << \" \";\n            }\n            cout << endl;\n        #endif\n    }\n\n    // 打印二维vector\n    template <typename T>\n    void print_2dvec(const vector<vector<T>>& vec2d, const string& name = \"\") {\n        #if DEBUG\n            if (!name.empty()) cout << name << \":\" << endl;\n            for (const auto& vec : vec2d) {\n                for (const auto& val : vec) {\n                    cout << val << \" \";\n                }\n                cout << endl;\n            }\n        #endif\n    }\n\n    // 打印pair（如pii/pll）\n    template <typename T1, typename T2>\n    void print_pair(const pair<T1, T2>& p, const string& name = \"\") {\n        #if DEBUG\n            if (!name.empty()) cout << name << \" = \";\n            cout << \"(\" << p.first << \", \" << p.second << \")\" << endl;\n        #endif\n    }\n\n    // 打印map/set\n    template <typename T>\n    void print_set(const set<T>& s, const string& name = \"\") {\n        #if DEBUG\n            if (!name.empty()) cout << name << \": \";\n            for (const auto& val : s) cout << val << \" \";\n            cout << endl;\n        #endif\n    }\n\n    template <typename K, typename V>\n    void print_map(const map<K, V>& m, const string& name = \"\") {\n        #if DEBUG\n            if (!name.empty()) cout << name << \":\" << endl;\n            for (const auto& [k, v] : m) cout << k << \" -> \" << v << endl;\n        #endif\n    }\n\n    // 计时工具：统计代码块执行时间（单位：毫秒）\n    class Timer {\n    private:\n        chrono::high_resolution_clock::time_point start;\n        string name;\n    public:\n        Timer(const string& timer_name = \"Code block\") : name(timer_name) {\n            #if DEBUG\n                start = chrono::high_resolution_clock::now();\n            #endif\n        }\n\n        \\x7eTimer() {\n            #if DEBUG\n                auto end = chrono::high_resolution_clock::now();\n                auto duration = chrono::duration_cast<chrono::milliseconds>(end - start).count();\n                cout << \"[Timer] \" << name << \" executed in \" << duration << \" ms\" << endl;\n            #endif\n        }\n    };\n\n    // 分隔线：用于区分不同调试模块的输出\n    void separator(const string& msg = \"\") {\n        #if DEBUG\n            cout << \"===================== \" << msg << \" =====================\" << endl;\n        #endif\n    }\n}\n\n// ====================== 数据结构 ======================\n// 1. 并查集（DSU）\nclass DSU {\nprivate:\n    vector<int> parent;\n    vector<int> rank;\npublic:\n    DSU(int n) {\n        parent.resize(n + 1); // 1-based\n        rank.resize(n + 1, 0);\n        FOR(i, 1, n) parent[i] = i;\n    }\n\n    int find(int x) { // 路径压缩\n        if (parent[x] != x) parent[x] = find(parent[x]);\n        return parent[x];\n    }\n\n    void unite(int x, int y) { // 按秩合并\n        x = find(x), y = find(y);\n        if (x == y) return;\n        if (rank[x] < rank[y]) parent[x] = y;\n        else {\n            parent[y] = x;\n            if (rank[x] == rank[y]) rank[x]++;\n        }\n    }\n\n    bool is_connected(int x, int y) {\n        return find(x) == find(y);\n    }\n};\n\n// 2. 线段树（单点更新 + 区间查询，支持求和/最大值/最小值）\ntemplate <typename T>\nclass SegmentTree {\nprivate:\n    vector<T> tree;\n    int n;\n    T init_val; // 初始化值（求和=0，最大值=-INF，最小值=INF）\n    T (*merge)(T, T); // 合并函数\n\n    void build(int node, int l, int r, const vector<T>& arr) {\n        if (l == r) {\n            tree[node] = arr[l];\n            return;\n        }\n        int mid = (l + r) / 2;\n        build(2 * node, l, mid, arr);\n        build(2 * node + 1, mid + 1, r, arr);\n        tree[node] = merge(tree[2 * node], tree[2 * node + 1]);\n    }\n\n    void update(int node, int l, int r, int pos, T val) {\n        if (l == r) {\n            tree[node] = val;\n            return;\n        }\n        int mid = (l + r) / 2;\n        if (pos <= mid) update(2 * node, l, mid, pos, val);\n        else update(2 * node + 1, mid + 1, r, pos, val);\n        tree[node] = merge(tree[2 * node], tree[2 * node + 1]);\n    }\n\n    T query(int node, int l, int r, int ql, int qr) {\n        if (qr < l || ql > r) return init_val;\n        if (ql <= l && r <= qr) return tree[node];\n        int mid = (l + r) / 2;\n        return merge(query(2 * node, l, mid, ql, qr), \n                     query(2 * node + 1, mid + 1, r, ql, qr));\n    }\n\npublic:\n    // 构造函数：arr为1-based数组，merge_func为合并规则，init为初始值\n    SegmentTree(const vector<T>& arr, T (*merge_func)(T, T), T init) {\n        n = arr.size() - 1;\n        init_val = init;\n        merge = merge_func;\n        tree.resize(4 * (n + 1), init_val);\n        build(1, 1, n, arr);\n    }\n\n    // 单点更新：pos为位置（1-based），val为新值\n    void update(int pos, T val) {\n        update(1, 1, n, pos, val);\n    }\n\n    // 区间查询：[ql, qr]（1-based）\n    T query(int ql, int qr) {\n        return query(1, 1, n, ql, qr);\n    }\n\n    // 预定义合并函数\n    static T sum(T a, T b) { return a + b; }\n    static T max_val(T a, T b) { return max(a, b); }\n    static T min_val(T a, T b) { return min(a, b); }\n};\n\n// 3. 单调栈（找下一个更大元素）\nvector<int> next_greater_element(vector<int>& nums) {\n    int n = nums.size();\n    vector<int> res(n, -1);\n    stack<int> st;\n    REP(i, n) {\n        while (!st.empty() && nums[i] > nums[st.top()]) {\n            res[st.top()] = nums[i];\n            st.pop();\n        }\n        st.push(i);\n    }\n    return res;\n}\n\n// ====================== 图论 ======================\n// 1. Dijkstra（单源最短路径，正权边）\nvector<ll> dijkstra(int start, int n, const vector<vector<pii>>& adj) {\n    vector<ll> dist(n + 1, LLINF);\n    dist[start] = 0;\n    priority_queue<pll, vector<pll>, greater<pll>> pq;\n    pq.push({0, start});\n\n    while (!pq.empty()) {\n        auto [d, u] = pq.top();\n        pq.pop();\n        if (d > dist[u]) continue;\n        for (auto [v, w] : adj[u]) {\n            if (dist[v] > dist[u] + w) {\n                dist[v] = dist[u] + w;\n                pq.push({dist[v], v});\n            }\n        }\n    }\n    return dist;\n}\n\n// ====================== 并查集（Kruskal依赖） ======================\nclass DSU {\nprivate:\n    vector<int> parent;\n    vector<int> rank;\npublic:\n    DSU(int n) {\n        parent.resize(n + 1); // 1-based\n        rank.resize(n + 1, 0);\n        for (int i = 1; i <= n; ++i) parent[i] = i;\n    }\n\n    int find(int x) { // 路径压缩（递归版）\n        if (parent[x] != x) parent[x] = find(parent[x]);\n        return parent[x];\n    }\n\n    bool unite(int x, int y) { // 按秩合并，返回是否合并成功\n        x = find(x), y = find(y);\n        if (x == y) return false;\n        if (rank[x] < rank[y]) parent[x] = y;\n        else {\n            parent[y] = x;\n            if (rank[x] == rank[y]) rank[x]++;\n        }\n        return true;\n    }\n\n    bool is_connected(int x, int y) {\n        return find(x) == find(y);\n    }\n};\n\n// ====================== Kruskal算法核心 ======================\nstruct Edge {\n    int u, v;    // 边的两个端点（1-based）\n    ll w;        // 边的权值（用ll避免溢出）\n    // 重载<，用于按权值升序排序（求最小生成树）\n    bool operator<(const Edge& rhs) const {\n        return w < rhs.w;\n    }\n};\n\n// Kruskal算法求解最小生成树\n// 参数：n-节点数，edges-所有边的集合\n// 返回值：pair<是否存在MST, MST的总权值>\npair<bool, ll> kruskal(int n, vector<Edge>& edges) {\n    // 1. 按边权升序排序（核心步骤）\n    sort(edges.begin(), edges.end());\n  \n    // 2. 初始化并查集\n    DSU dsu(n);\n  \n    ll mst_sum = 0; // MST的总权值\n    int edge_cnt = 0; // 已选入MST的边数\n  \n    // 3. 遍历所有边，贪心选边\n    for (const Edge& e : edges) {\n        int u = e.u, v = e.v;\n        ll w = e.w;\n  \n        // 若u和v不连通，则选这条边加入MST\n        if (dsu.unite(u, v)) {\n            mst_sum += w;\n            edge_cnt++;\n            // 提前终止：MST需要n-1条边\n            if (edge_cnt == n - 1) break;\n        }\n    }\n  \n    // 4. 判断是否存在MST（所有节点连通，即选够n-1条边）\n    bool has_mst = (edge_cnt == n - 1);\n    return {has_mst, mst_sum};\n}\n\n// ====================== 扩展：求最大生成树 ======================\n// 只需修改Edge的排序规则（降序）\nstruct MaxEdge {\n    int u, v;\n    ll w;\n    bool operator<(const MaxEdge& rhs) const {\n        return w > rhs.w; // 降序排序\n    }\n};\n\npair<bool, ll> kruskal_max(int n, vector<MaxEdge>& edges) {\n    sort(edges.begin(), edges.end());\n    DSU dsu(n);\n    ll mst_sum = 0;\n    int edge_cnt = 0;\n    for (const MaxEdge& e : edges) {\n        if (dsu.unite(e.u, e.v)) {\n            mst_sum += e.w;\n            edge_cnt++;\n            if (edge_cnt == n - 1) break;\n        }\n    }\n    return {edge_cnt == n - 1, mst_sum};\n}\n\n\n// 2. 拓扑排序（Kahn算法，返回拓扑序，空表示有环）\nvector<int> topological_sort(int n, const vector<vector<int>>& adj) {\n    vector<int> in_degree(n + 1, 0);\n    FOR(u, 1, n) for (int v : adj[u]) in_degree[v]++;\n\n    queue<int> q;\n    FOR(u, 1, n) if (in_degree[u] == 0) q.push(u);\n\n    vector<int> res;\n    while (!q.empty()) {\n        int u = q.front();\n        q.pop();\n        res.pb(u);\n        for (int v : adj[u]) {\n            in_degree[v]--;\n            if (in_degree[v] == 0) q.push(v);\n        }\n    }\n    return res.size() == n ? res : vector<int>();\n}\n\n// ====================== 数论 ======================\n// 1. 快速幂（含模）\nll quick_pow(ll a, ll b, ll mod = MOD) {\n    ll res = 1;\n    a %= mod;\n    while (b) {\n        if (b & 1) res = res * a % mod;\n        a = a * a % mod;\n        b >>= 1;\n    }\n    return res;\n}\n\n// 2. 欧拉筛（线性筛素数）\nvector<int> euler_sieve(int n) {\n    vector<bool> is_prime(n + 1, true);\n    vector<int> primes;\n    is_prime[0] = is_prime[1] = false;\n    FOR(i, 2, n) {\n        if (is_prime[i]) primes.pb(i);\n        for (int p : primes) {\n            if (i * p > n) break;\n            is_prime[i * p] = false;\n            if (i % p == 0) break;\n        }\n    }\n    return primes;\n}\n\n// 3. 扩展欧几里得（解ax + by = gcd(a,b)）\nll exgcd(ll a, ll b, ll& x, ll& y) {\n    if (b == 0) {\n        x = 1, y = 0;\n        return a;\n    }\n    ll d = exgcd(b, a % b, y, x);\n    y -= a / b * x;\n    return d;\n}\n\n// ====================== 动态规划 ======================\n// 1. 01背包（n件物品，容量m，v价值，w重量）\nll knapsack_01(int n, int m, vector<int>& v, vector<int>& w) {\n    vector<ll> dp(m + 1, 0);\n    FOR(i, 1, n) FORD(j, m, w[i]) \n        dp[j] = max(dp[j], dp[j - w[i]] + v[i]);\n    return dp[m];\n}\n\n// 2. 完全背包（物品可无限选）\nll knapsack_complete(int n, int m, vector<int>& v, vector<int>& w) {\n    vector<ll> dp(m + 1, 0);\n    FOR(i, 1, n) FOR(j, w[i], m) \n        dp[j] = max(dp[j], dp[j - w[i]] + v[i]);\n    return dp[m];\n}\n\n// ====================== 字符串 ======================\n// KMP算法（模式匹配）\nnamespace KMP {\n    vector<int> get_next(const string& pat) {\n        int n = pat.size();\n        vector<int> nxt(n, 0);\n        int j = 0;\n        FOR(i, 1, n - 1) {\n            while (j > 0 && pat[i] != pat[j]) j = nxt[j - 1];\n            if (pat[i] == pat[j]) j++;\n            nxt[i] = j;\n        }\n        return nxt;\n    }\n\n    vector<int> match(const string& s, const string& pat) {\n        vector<int> nxt = get_next(pat);\n        vector<int> res;\n        int j = 0;\n        REP(i, s.size()) {\n            while (j > 0 && s[i] != pat[j]) j = nxt[j - 1];\n            if (s[i] == pat[j]) j++;\n            if (j == pat.size()) {\n                res.pb(i - j + 1);\n                j = nxt[j - 1];\n            }\n        }\n        return res;\n    }\n}\n\n\n#define For(i, a, b) for (int i = a; i <= b; ++i)\n#define Ford(i, a, b) for (int i = a; i >= b; --i)\n#define rep(i, n) for (int i = 0; i < n; ++i)\n#define pb push_back\n#define mp make_pair\n\nconst int N = 1e5 + 10;\n\n\n\nint main() {\n    fast_io();\n  \n    return 0;\n}\n```\n","tags":["C++"]},{"title":"图论常用模板","url":"/2025/12/10/图论常用模板/","content":"\n# 图论核心算法模板\n\n## 1. 图的存储模板\n### 邻接表（稀疏图首选）\n```cpp\n#include <vector>\nusing namespace std;\n\nconst int N = 1e5 + 10; // 节点数上限\nvector<pair<int, int>> adj[N]; // adj[u]存储(v, w)：u→v，边权w\n\n// 建图：添加有向边u→v，边权w（无向边需加两次u→v和v→u）\nvoid add_edge(int u, int v, int w = 1) { // 无权重时w默认1\n    adj[u].emplace_back(v, w);\n}\n\n// 遍历u的所有出边\nvoid traverse(int u) {\n    for (auto &e : adj[u]) {\n        int v = e.first, w = e.second;\n        // 处理边u→v\n    }\n}\n```\n\n### 链式前向星（高效存边，竞赛高频）\n\n### 第一种 使用结构体存储\n\n```cpp\n#include <cstring>\nusing namespace std;\n\nconst int N = 1e5 + 10, M = 2e5 + 10; // N节点数，M边数上限\nint head[N], idx; // head[u]表示u的第一条边索引，idx边的计数器\nstruct Edge { int v, w, next; } edge[M]; // next指向下一条边\n\n// 初始化\nvoid init() {\n    memset(head, -1, sizeof head);\n    idx = 0;\n}\n\n// 建图：添加有向边u→v，边权w（无向边需加两次）\nvoid add_edge(int u, int v, int w = 1) {\n    edge[idx] = {v, w, head[u]};\n    head[u] = idx++;\n}\n\n// 遍历u的所有出边\nvoid traverse(int u) {\n    for (int i = head[u]; i != -1; i = edge[i].next) {\n        int v = edge[i].v, w = edge[i].w;\n        // 处理边u→v\n    }\n}\n```\n\n#### 第二种 使用数组存储\n\n[链式前向星](https://gitee.com/xyb7910/algo_cpp/blob/master/%E8%AE%B2%E4%B9%89/%E9%93%BE%E5%BC%8F%E5%89%8D%E5%90%91%E6%98%9F/%E8%AE%B2%E4%B9%89/%E6%95%B0%E7%BB%84%E6%A8%A1%E6%8B%9F%E9%82%BB%E6%8E%A5%E8%A1%A8.md)\n\n---\n\n## 2. 图的遍历模板\n\n### DFS（递归版，适用于无栈溢出场景）\n\n[AcWing 846. 树的重心](https://www.acwing.com/problem/content/848/)\n\n**模板**：\n\n```cpp\n#include <vector>\n#include <cstring>\nusing namespace std;\n\nconst int N = 1e5 + 10;\nvector<int> adj[N];\nbool st[N]; // 标记是否访问过\n\nvoid dfs(int u) {\n    st[u] = true; // 标记访问\n    for (int v : adj[u]) {\n        if (!st[v]) {\n            dfs(v);\n            // 回溯时操作（如统计子树大小）\n        }\n    }\n}\n```\n\n**例题代码**:\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nconst int N = 1e5 + 10, M = 2 * N;\nint n, ans=N;\nint h[N], e[M], ne[M], idx, st[N];\nvoid add(int a, int b)\n{\n    e[idx] = b, ne[idx] = h[a], h[a] = idx++;\n}\n\nint dfs(int u)\n{\n    st[u] = 1; // 防止重复遍历 \n    int sum = 1, res = 0;\n    for (int i = h[u]; i != -1; i = ne[i])\n    {\n        int j = e[i];\n        if(!st[j])\n        {\n            int s = dfs(j);\n            res = max(res, s); // 先在当前u的子树中求一个节点最大值 \n            sum += s; // 表示u节点子树的节点的总和 \n        }\n    }\n    res = max(res, n - sum); // 再在以u的父节点为子树的求一个节点最大值 \n    ans = min(ans, res); // 求最大值的最小值 \n    return sum;\n}\n\nint main()\n{\n    cin >> n;\n    memset(h, -1, sizeof h);\n    for (int i = 1, u, v; i < n; i ++)  \n    {\n        cin >> u >> v;\n        add(u, v);\n        add(v, u);\n    }\n    dfs(1);\n    cout << ans << endl;\n    return 0;\n}\n```\n\n### BFS（队列版，无权图最短路径）\n\n[AcWing 847. 图中点的层次](https://www.acwing.com/problem/content/849/)\n\n**模板**：\n\n```cpp\n#include <vector>\n#include <queue>\n#include <cstring>\nusing namespace std;\n\nconst int N = 1e5 + 10;\nvector<int> adj[N];\nbool st[N]; // 计算距离的时候，可省略\nint dist[N]; // 存储到起点的距离\n\nvoid bfs(int start) {\n    memset(st, false, sizeof st);\n    memset(dist, -1, sizeof dist);\n    queue<int> q;\n    q.push(start);\n    st[start] = true;\n    dist[start] = 0;\n  \n    while (!q.empty()) {\n        int u = q.front();\n        q.pop();\n        for (int v : adj[u]) {\n            if (!st[v]) {\n                // if这里可以直接对下一个点的距离是否为 -1，进行判断\n                st[v] = true;\n                dist[v] = dist[u] + 1;\n                q.push(v);\n            }\n        }\n    }\n}\n```\n\n**例题代码**:\n\n```cpp\n// 使用邻接表存储图\n#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\ntypedef pair<int, int> pii;\nconst int N = 1e5 + 10;\nvector<pii> adj[N];\nint n, m, dist[N];\nvoid add(int u, int v, int w)\n{\n    adj[u].emplace_back(v, w);\n}\n\nint bfs() \n{\n    memset(dist, -1, sizeof dist);\n  \n    queue<int> q;\n  \n    q.push(1);\n    dist[1] = 0;\n    while(q.size())\n    {\n        int t = q.front(); q.pop();\n        for (auto &e : adj[t])\n        {\n            int nxt = e.first, distance = e.second;\n            if(dist[nxt] == -1)\n            {\n                dist[nxt] = dist[t] + distance;\n                q.push(nxt);\n            }\n        }\n    }\n    return dist[n];\n}\n\nint main()\n{\n    cin >> n >> m;\n    for (int i = 1, u, v; i <= m; i ++)\n    {\n        cin >> u >> v;\n        add(u, v, 1);\n    } \n    cout << bfs() << endl;\n    return 0;\n}\n```\n\n```cpp\n// 使用数组模拟邻接表\n#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nconst int N = 1e5 + 10;\nint n, m;\nint h[N], e[N], ne[N], idx;\nint dist[N], q[N];\n\nvoid add(int a, int b) {\n    e[idx] = b;\n    ne[idx] = h[a];\n    h[a] = idx;\n    idx ++;\n}\n\n\n// 手写队列实现\nint bfs() {\n    memset(dist, -1, sizeof dist);\n\n    int tt = 0, hh = 0;\n\n    q[0] = 1;\n    dist[1] = 0;\n\n    while(hh <= tt) {\n        auto t = q[hh ++];\n        for (int i = h[t]; i != -1; i = ne[i]) {\n            int j = e[i];\n            if(dist[j] == -1) {\n                dist[j] = dist[t] + 1;\n                q[++ tt] = j;\n            }\n        }\n    }\n    return dist[n];\n}\n\nint bfs_stl() {\n    memset(dist, -1, sizeof dist);\n    queue<int> q;\n\n\n    q.push(1);\n    dist[1] = 0;\n    while(q.size()) {\n        auto t = q.front();\n        q.pop();\n\n        for (int i = h[t]; i != -1; i = ne[i]) {\n            int j = e[i];\n            if (dist[j] == -1) {\n                dist[j] = dist[t] + 1;\n                q.push(j);\n            }\n        }\n    }\n    return dist[n];\n}\n\nint main()\n{\n    cin >> n >> m;\n    memset(h, -1, sizeof h); // 一定要注意初始化表头 \n    for (int i = 0, u, v; i < m; i ++) {\n        int a, b;\n        cin >> u >> v;\n        add(u, v);\n    }\n    cout << bfs_stl() << endl;  \n    return 0;\n}\n```\n\n---\n\n## 3. 并查集（路径压缩+按秩合并）\n\n```cpp\nconst int N = 1e5 + 10;\nint parent[N]; // 父节点\nint rank_[N]; // 秩（树的高度）\n\n// 初始化\nvoid init() {\n    for (int i = 0; i < N; i++) {\n        parent[i] = i;\n        rank_[i] = 1;\n    }\n}\n\n// 查找根节点（路径压缩）\nint find(int x) {\n    if (parent[x] != x) parent[x] = find(parent[x]);\n    return parent[x];\n}\n\n// 合并（按秩合并）\nvoid unite(int x, int y) {\n    x = find(x), y = find(y);\n    if (x == y) return;\n    if (rank_[x] < rank_[y]) swap(x, y);\n    parent[y] = x;\n    if (rank_[x] == rank_[y]) rank_[x]++;\n}\n```\n\n---\n\n## 4. 最短路径算法模板\n\n### Dijkstra（正权图单源最短路径）\n\n#### 算法描述：\n\n1. 初始化 dist[1] = 0, 其余节点的 dist 值为无穷大。\n2. 找出第一个未被标记的，dist[x] 最小的节点 x, 然后标记节点 x。\n3. 扫描节点 x 的所有出边 (x, y, z)， 若 dist[y] > dist[x] + z， 则使用 dist[x] + z 更新 dist[y]。\n4. 重复上述 2 ～ 3 两个步骤，直到所有的节点都被标记。\n\n[AcWing 849. Dijkstra求最短路 I](https://www.acwing.com/problem/content/851/)\n\n**例题代码**:\n\n```cpp\n// 稠密图这里使用邻接数组\n#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nconst int N = 550;\nint n, m;\nint g[N][N], dist[N], st[N];\n\nint dijkstra()\n{\n    // 时间复杂度为 O(n^2)\n    memset(dist, 0x3f, sizeof dist);\n    dist[1] = 0;\n  \n    for (int i = 1; i < n; i ++) // 重复 n - 1 次\n    {\n        int t = -1;\n        for (int j = 1; j <= n; j ++) // 找到未标记节点中 dist 最小的 (瓶颈主要在这里，可使用二叉堆优化)\n        {\n            if(!st[j] && (t == -1 || dist[t] > dist[j])) t = j;\n        }\n        st[t] = 1;\n        // 用全局最小值点 x 更新其他节点\n        for (int j = 1; j <= n; j ++)\n            dist[j] = min(dist[j], dist[t] + g[t][j]);\n    }\n  \n    if(dist[n] == 0x3f3f3f3f) return -1;\n    else return dist[n];\n}\n\n\nint main()\n{\n    cin >> n >> m;\n    memset(g, 0x3f, sizeof g);\n    for (int i = 1, u, v, w; i <= m; i ++)\n    {\n        cin >> u >> v >> w;\n        g[u][v] = min(g[u][v], w);\n    }\n    cout << dijkstra();\n    return 0;\n}\n```\n\n```cpp\n// 使用邻接表实现\n#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nconst int N = 1e6 + 10;\ntypedef pair<int, int> pii;\nint n, m; \nint e[N], ne[N], h[N], val[N], dist[N], st[N], idx;\nvoid add(int a, int b, int w)\n{\n    e[++ idx] = b, val[idx] = w, ne[idx] = h[a], h[a] = idx;\n}\n\nint dijkstra()\n{\n    memset(dist, 0x3f, sizeof dist);\n    dist[1] = 0;\n  \n    priority_queue<pii, vector<pii>, greater<pii>> q;\n    q.push({0, 1});\n  \n  \n    while(q.size())\n    {\n        pii t = q.top(); q.pop();\n    \n        int distance = t.first, ver = t.second;\n    \n        if(st[ver]) continue;\n        st[ver] = 1;\n    \n        for (int i = h[ver]; i != -1; i = ne[i])\n        {\n            int j = e[i];\n            if(dist[j] > dist[ver] + val[i])\n            {\n                dist[j] = dist[ver] + val[i];\n                q.push({dist[j], j});\n            }\n        }\n    }\n  \n    if(dist[n] == 0x3f3f3f3f) return -1;\n    else return dist[n];\n}\n\nint main()\n{\n    memset(h, -1, sizeof h);\n    cin >> n >> m;\n    for (int i = 1, u, v, w; i <= m; i ++)\n    {\n        cin >> u >> v >> w;\n        add(u, v, w);\n    }\n    cout << dijkstra();\n    return 0;   \n}\n```\n\n**模板**:\n\n```cpp\n#include <vector>\n#include <queue>\n#include <cstring>\nusing namespace std;\n\ntypedef pair<int, int> PII; // 第一维距离，第二维节点\nconst int N = 1e5 + 10, INF = 0x3f3f3f3f;\nvector<PII> adj[N];\nint dist[N];\nbool st[N]; // 标记是否确定最短距离\n\nvoid dijkstra(int start) {\n    memset(dist, 0x3f, sizeof dist);\n    memset(st, false, sizeof st);\n    priority_queue<PII, vector<PII>, greater<PII>> heap; // 小根堆\n    dist[start] = 0;\n    heap.push({0, start});\n  \n    while (!heap.empty()) {\n        auto [d, u] = heap.top();\n        heap.pop();\n        if (st[u]) continue;\n        st[u] = true;\n        for (auto [v, w] : adj[u]) {\n            if (dist[v] > dist[u] + w) {\n                dist[v] = dist[u] + w;\n                heap.push({dist[v], v});\n            }\n        }\n    }\n}\n```\n\n### Floyd-Warshall（多源最短路径）\n\n```cpp\nconst int N = 510, INF = 0x3f3f3f3f;\nint dist[N][N]; // dist[i][j]表示i到j的最短距离\nint n; // 节点数\n\n// 初始化\nvoid init() {\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= n; j++) {\n            dist[i][j] = i == j ? 0 : INF;\n        }\n    }\n}\n\n// 核心算法\nvoid floyd() {\n    for (int k = 1; k <= n; k++) { // 中间节点\n        for (int i = 1; i <= n; i++) {\n            for (int j = 1; j <= n; j++) {\n                if (dist[i][k] != INF && dist[k][j] != INF) {\n                    dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);\n                }\n            }\n        }\n    }\n}\n```\n\n### SPFA（队列优化，负权图单源最短路径，可检测负环）\n\n#### 算法描述 (求最短路)\n\n1. 建立一个的队列，最初队列中只含有起点 1。\n2. 取出对头节点 x，扫描它的所有出边 (x, y, z), 若 dist[y] > dist[x] + z, 则使用 dist[x] + z 更新 dist[y]。同时，若 y 不在队列中，则把 y 入队。\n3. 重复以上操作，直至队列为空。\n\n[AcWing 851. spfa求最短路](https://www.acwing.com/problem/content/853/)\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 1e5 + 10;\nint n, m;\nint h[N], ne[N], e[N], w[N], idx;\nint dist[N], st[N];\n\ninline void add(int a, int b, int v)\n{\n    e[++ idx] = b, w[idx] = v, ne[idx] = h[a], h[a] = idx;\n}\n\nint spfa()\n{\n    memset(dist, 0x3f, sizeof dist);\n    queue<int> q;\n  \n    q.push(1);\n  \n    dist[1] = 0;\n    st[1] = 1; // 标记节点是否在队列之中\n  \n    while(q.size())\n    {\n        int t = q.front(); q.pop();\n    \n        st[t] = 0;\n    \n        for (int i = h[t]; ~i; i = ne[i])\n        {\n            int j = e[i];\n            if(dist[j] > dist[t] + w[i])\n            {\n                dist[j] = dist[t] + w[i];\n                if(!st[j])\n                {\n                    q.push(j);\n                    st[j] = 1;\n                }\n            }\n        }\n    }\n  \n    return dist[n];\n}\n\nint main()\n{\n    cin >> n >> m;\n    memset(h, -1, sizeof h);\n    for (int i = 1, u, v, val; i <= m; i ++)\n    {\n        cin >> u >> v >> val;\n        add(u, v, val);\n    }\n    int t = spfa();\n    if(t == 0x3f3f3f3f) puts(\"impossible\");\n    else cout << t << \"\\n\";\n    return 0;\n}\n```\n\n#### 判断负环：\n\n- 若最短路径不存在负权回路，**任意两点间最短简单路径最多含 n-1  条边**n 为总点数。因此通过 n-1  次松弛操作可得到最短距离；若仍能松弛，则存在可无限减少路径长度的负权环。\n\n##### 常用方法\n\n统计每个结点被入队/被松弛的次数  cnt[v] 。当 $cnt[v] \\geq n$ 或 $>n-1$ 时，说明从源点到该结点存在一条含至少 n  条边且仍能松弛的路径，即存在**从源可达的负权回路**。\n\n###### 实现要点\n\n- 松弛时的计数逻辑：\n  - 当松弛到  v 且需要将 v 放入队列时，执行 `cnt[v]++`；若 `cnt[v] >= n`，则报告负环。\n  - 也可在每次**真正更新  dist[v]** 时执行 `cnt[v]++`，两种方式等价用于检测。\n\n##### 负环回溯方法\n\n- 记录每次松弛时的前驱 `pre[v] = u`。\n- 当检测到结点  x  满足 `cnt[x] > n`：\n  1. 令 y = x ，重复  n  次 `y = pre[y]`（确保跳到环上的点）；\n  2. 从 y 沿 `pre` 链回溯并收集节点，直到回到  y ，即可得到一个负权回路。\n\n##### 可达性与全图负环检测\n\n- 上述方法仅能检测“从源可达”的负环。若要检测图中**任意负环**，可添加一个**超级源点**，向所有结点连权值为 0 的边，再用算法跑一次（或对每个连通分量分别处理）。\n\n##### 简短结论\n\nSPFA 通过统计每个节点被松弛/入队次数 cnt[v] ，一旦  cnt[v] >= n  即可判定存在**从源可达的负权回路**；回溯时利用前驱链并先跳 n 步，确保进入环内。\n\n[AcWing 852. spfa判断负环](https://www.acwing.com/problem/content/854/)\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 1e5 + 10;\nint n, m;\nint e[N], ne[N], w[N], h[N], idx;\nint dist[N], cnt[N], st[N];\n// 这里的 dist 数组可以省略掉， 如果存在负权回路的话， dist 数组值会无限被更新。\n// 但是，cnt 数组防止了，无限继续先去，cnt 数组用来存储入队次数。\n// 存在一个点数为 n 的图，那么到当前节点的入队次数最大为 n - 1，\n// 当入队次数 >= n 时候，必然存在负数回路。\ninline void add(int a, int b, int v)\n{   \n    e[++ idx] = b, w[idx] = v, ne[idx] = h[a], h[a] = idx;\n}\n\nbool spfa()\n{\n    memset(dist, 0x3f, sizeof dist);\n    queue<int> q; \n    // 这里因为要判断图中是否存在负环\n    // 那么，需要将所有节点都先入队，然后计算 cnt 数组\n    for (int i = 1; i <= n; i ++)\n    {\n        st[i] = 1;\n        q.push(i);\n    }\n  \n    while(q.size())\n    {\n        int t = q.front();\n        q.pop();\n    \n        st[t] = 0;\n    \n        for (int i = h[t]; ~i; i = ne[i])\n        {\n            int j = e[i];\n            if(dist[j] > dist[t] + w[i])\n            {\n                dist[j] = dist[t] + w[i]; // 更新距离后记得更新 cnt 数组\n                cnt[j] = cnt[t] + 1;\n            \n                if(cnt[j] >= n) return 1;\n                if(!st[j])\n                {\n                    q.push(j);\n                    st[j] = 1;\n                }\n            }\n        }\n    }\n    return 0;\n}\n\nint main() \n{\n    cin >> n >> m;\n    memset(h, -1, sizeof h);\n    for (int i = 1, u, v, val; i <= m; i ++)\n    {\n        cin >> u >> v >> val;\n        add(u, v, val);\n    }\n    if(spfa()) puts(\"Yes\");\n    else puts(\"No\");\n    return 0;\n}\n```\n\n**模板**：\n\n```cpp\n#include <vector>\n#include <queue>\n#include <cstring>\nusing namespace std;\n\nconst int N = 1e5 + 10, INF = 0x3f3f3f3f;\nvector<pair<int, int>> adj[N];\nint dist[N];\nint cnt[N]; // 记录入队次数，判断负环\nbool inqueue[N]; // 标记是否在队列中\nint n, m; // 节点数、边数\n\n// 返回true表示存在负环\nbool spfa(int start) {\n    memset(dist, 0x3f, sizeof dist);\n    memset(cnt, 0, sizeof cnt);\n    memset(inqueue, false, sizeof inqueue);\n    queue<int> q;\n    dist[start] = 0;\n    q.push(start);\n    inqueue[start] = true;\n  \n    while (!q.empty()) {\n        int u = q.front();\n        q.pop();\n        inqueue[u] = false;\n        for (auto [v, w] : adj[u]) {\n            if (dist[v] > dist[u] + w) {\n                dist[v] = dist[u] + w;\n                cnt[v] = cnt[u] + 1;\n                if (cnt[v] >= n) return true; // 入队n次，存在负环\n                if (!inqueue[v]) { \n                    q.push(v);\n                    inqueue[v] = true;\n                }\n            }\n        }\n    }\n    return false;\n}\n```\n\n---\n\n## 5. 最小生成树模板\n\n### Kruskal（并查集+排序，稀疏图首选）\n\n```cpp\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nconst int N = 1e5 + 10, M = 2e5 + 10;\nstruct Edge {\n    int u, v, w;\n    bool operator<(const Edge &e) const {\n        return w < e.w; // 按边权升序排序\n    }\n} edges[M];\nint parent[N];\nint n, m; // 节点数、边数\n\n// 并查集find和init函数同前\nint find(int x) { /* 路径压缩实现 */ }\nvoid init() { /* 初始化实现 */ }\n\nint kruskal() {\n    sort(edges, edges + m);\n    init();\n    int res = 0, cnt = 0; // res总权值，cnt选边数\n    for (int i = 0; i < m; i++) {\n        int u = edges[i].u, v = edges[i].v, w = edges[i].w;\n        u = find(u), v = find(v);\n        if (u != v) {\n            unite(u, v);\n            res += w;\n            cnt++;\n            if (cnt == n - 1) break; // 选够n-1条边，退出\n        }\n    }\n    return cnt == n - 1 ? res : -1; // 不连通返回-1\n}\n```\n\n### Prim（堆优化，稠密图首选）\n\n```cpp\n#include <vector>\n#include <queue>\n#include <cstring>\nusing namespace std;\n\ntypedef pair<int, int> PII; // 第一维边权，第二维节点\nconst int N = 1e5 + 10, INF = 0x3f3f3f3f;\nvector<PII> adj[N];\nbool st[N]; // 标记是否已加入生成树\nint n, m;\n\nint prim() {\n    memset(st, false, sizeof st);\n    priority_queue<PII, vector<PII>, greater<PII>> heap;\n    heap.push({0, 1}); // 从节点1开始（可修改起点）\n    int res = 0, cnt = 0;\n  \n    while (!heap.empty()) {\n        auto [w, u] = heap.top();\n        heap.pop();\n        if (st[u]) continue;\n        st[u] = true;\n        res += w;\n        cnt++;\n        for (auto [v, ww] : adj[u]) {\n            if (!st[v]) heap.push({ww, v});\n        }\n    }\n    return cnt == n ? res : -1; // 不连通返回-1\n}\n```\n\n---\n\n## 6. 强连通分量（Tarjan算法+缩点）\n\n```cpp\n#include <vector>\n#include <stack>\n#include <cstring>\nusing namespace std;\n\nconst int N = 1e5 + 10;\nvector<int> adj[N];\nint dfn[N], low[N], timestamp; // dfn时间戳，low能到达的最早时间戳\nbool in_stack[N]; // 标记是否在栈中\nstack<int> stk;\nint scc_cnt; // 强连通分量数量\nint id[N]; // 每个节点所属的强连通分量编号\nint n, m;\n\nvoid tarjan(int u) {\n    dfn[u] = low[u] = ++timestamp;\n    stk.push(u);\n    in_stack[u] = true;\n    for (int v : adj[u]) {\n        if (!dfn[v]) {\n            tarjan(v);\n            low[u] = min(low[u], low[v]);\n        } else if (in_stack[v]) {\n            low[u] = min(low[u], dfn[v]);\n        }\n    }\n    // 找到强连通分量的根\n    if (dfn[u] == low[u]) {\n        scc_cnt++;\n        int v;\n        do {\n            v = stk.top();\n            stk.pop();\n            in_stack[v] = false;\n            id[v] = scc_cnt;\n        } while (v != u);\n    }\n}\n\n// 缩点：构建新的DAG\nvector<int> new_adj[N];\nint scc_size[N]; // 每个强连通分量的大小\n\nvoid shrink() {\n    memset(dfn, 0, sizeof dfn);\n    memset(low, 0, sizeof low);\n    memset(in_stack, false, sizeof in_stack);\n    timestamp = scc_cnt = 0;\n    for (int i = 1; i <= n; i++) {\n        if (!dfn[i]) tarjan(i);\n    }\n    // 统计每个SCC大小\n    for (int i = 1; i <= n; i++) scc_size[id[i]]++;\n    // 建DAG\n    for (int u = 1; u <= n; u++) {\n        for (int v : adj[u]) {\n            if (id[u] != id[v]) {\n                new_adj[id[u]].push_back(id[v]);\n            }\n        }\n    }\n}\n```\n\n---\n\n## 7. 二分图匹配（匈牙利算法）\n\n```cpp\n#include <vector>\n#include <cstring>\nusing namespace std;\n\nconst int N = 1e3 + 10, M = 1e5 + 10;\nvector<int> adj[N]; // 左部节点→右部节点\nint match[M]; // 右部节点匹配的左部节点\nbool st[M]; // 标记右部节点是否被访问\nint n1, n2; // 左部节点数、右部节点数\n\n// 尝试给左部节点u找匹配\nbool find(int u) {\n    for (int v : adj[u]) {\n        if (!st[v]) {\n            st[v] = true;\n            if (match[v] == 0 || find(match[v])) {\n                match[v] = u;\n                return true;\n            }\n        }\n    }\n    return false;\n}\n\n// 求最大匹配数\nint hungarian() {\n    memset(match, 0, sizeof match);\n    int res = 0;\n    for (int u = 1; u <= n1; u++) {\n        memset(st, false, sizeof st);\n        if (find(u)) res++;\n    }\n    return res;\n}\n```\n\n---\n\n## 8. 拓扑排序（Kahn算法）\n\n```cpp\n#include <vector>\n#include <queue>\n#include <cstring>\nusing namespace std;\n\nconst int N = 1e5 + 10;\nvector<int> adj[N];\nint in_degree[N]; // 入度\nint topo[N]; // 存储拓扑序列\nint n, m;\n\n// 返回拓扑序列长度，0表示有环\nint kahn() {\n    queue<int> q;\n    int cnt = 0; // 拓扑序列长度\n    // 入度为0的节点入队\n    for (int i = 1; i <= n; i++) {\n        if (in_degree[i] == 0) q.push(i);\n    }\n    while (!q.empty()) {\n        int u = q.front();\n        q.pop();\n        topo[cnt++] = u;\n        for (int v : adj[u]) {\n            in_degree[v]--;\n            if (in_degree[v] == 0) q.push(v);\n        }\n    }\n    return cnt == n ? cnt : 0;\n}\n```\n\n---\n\n## 9. 网络流（Dinic算法，最大流）\n\n```cpp\n#include <vector>\n#include <queue>\n#include <cstring>\nusing namespace std;\n\nconst int N = 1e4 + 10, M = 2e5 + 10, INF = 1e9;\nstruct Edge {\n    int v, c, rev; // 终点、剩余容量、反向边索引\n};\nvector<Edge> adj[N];\nint level[N]; // 分层图深度\nint ptr[N]; // 当前弧优化\nint n, m, s, t; // 节点数、边数、源点、汇点\n\n// 添加边u→v，容量c\nvoid add_edge(int u, int v, int c) {\n    adj[u].push_back({v, c, (int)adj[v].size()});\n    adj[v].push_back({u, 0, (int)adj[u].size() - 1}); // 反向边容量0\n}\n\n// BFS构建分层图\nbool bfs() {\n    memset(level, -1\n```\n","tags":["图论"],"categories":["算法"]}]